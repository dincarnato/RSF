#!/usr/bin/perl

##
# RT Count (v1.0.0a)
# Epigenetics Unit @ HuGeF [Human Genetics Foundation]
#
# Author:  Danny Incarnato (danny.incarnato[at]hugef-torino.org)
# Summary: Performs reads mapping, and calculates per-base RT-stops and coverage
#
# This program is free software, and can be redistribute  and/or modified
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# Please see <http://www.gnu.org/licenses/> for more informations.
##

use strict;
use Config;
use Fcntl qw(SEEK_SET);
use File::Basename;
use File::Copy;
use File::Path qw(mkpath rmtree);
use File::Spec;
use FindBin qw($Bin);
use Fcntl qw(SEEK_END);
use Getopt::Long qw(:config no_ignore_case);
use threads;
use threads::shared;
use Thread::Queue;

use lib $Bin . "/lib";

use Core::Utils;
use Core::Mathematics qw(:all);
use Core::Process::Queue;
use Core::Statistics;
use Data::IO::Sequence;
use Data::Sequence::Utils;
use Term::Table;

$|++;

die "\n  [!] Error: This program requires ithreads." .
    "\n             Please recompile Perl with ithreads support and try again\n\n" unless(defined $Config{useithreads});

my ($tmp, $tmpdir, $output, $keep,
    $trim3, $trim5, $bv, $bn,
    $ba, $bp, $bi, $bc,
    $fa, $fq, $fl, $bowtie,
    $fastx, $samtools, $multifasta, $sam,
    $sorted, $clipped, $help, $overwrite,
    $bm, $nobam, $error, $fastq,
    $bam_trim5, $hex, $offset, $threads,
    $processmanager, $madetmp, $qcounter, $qresults,
    $table, @bam_trim5, @tmp, @pool,
    %transcripts, %bases, %spacer);

my $lock : shared;

$tmp = int(rand(time())) + int(rand(time()));
$tmpdir = "/tmp/";
$output = "rt_count/";
$fa = "TGGAATTCTCGGGTGCCAAGG";
$fl = 35;
$fq = 33;
$trim5 = 0;
$trim3 = 0;
$bn = 2;
$bp = 1;
$bc = 128;
$bm = 1;
$fastq = 0;
$hex = 5;
$offset = 0;
$threads = 1;
$madetmp = 0;
%bases = map { $_ => --$hex } qw(N T G C A);

do {
    
    local $SIG{__WARN__} = sub { };

    GetOptions( "h|help"                  => \$help,
                "t|tmp-dir=s"             => \$tmpdir,
                "o|output-dir=s"          => \$output,
                "ow|overwrite"            => \$overwrite,
                "k|keep"                  => \$keep,
                "n|no-bam"                => \$nobam,
                "t5|trim-5prime=s"        => \$bam_trim5,
                "b5|bowtie-trim-5prime=i" => \$trim5,
                "b3|bowtie-trim-3prime=i" => \$trim3,
                "bv|bowtie-v=i"           => \$bv,
                "bn|bowtie-n=i"           => \$bn,
                "ba|bowtie-all"           => \$ba,
                "bm|bowtie-max=i"	      => \$bm,
                "bp|bowtie-threads=i"     => \$bp,
                "bi|bowtie-index=s"       => \$bi,
                "bc|bowtie-chunkmbs=i"    => \$bc,
                "fa|fastx-adapter=s"      => \$fa,
                "fq|fastx-qual=i"         => \$fq,
                "fl|fastx-len=i"          => \$fl,
                "c|clipped"	              => \$clipped,
                "b|bowtie=s"              => \$bowtie,
                "fx|fastx=s"              => \$fastx,
                "s|samtools=s"            => \$samtools,
                "r|sorted"                => \$sorted,
                "p|processors=i"          => \$threads,
                "f|fasta=s"               => \$multifasta ) or help(1);

};

help() if ($help);

$tmpdir =~ s/\/?$/\//;
$output =~ s/\/?$/\//;
$bowtie = which("bowtie") if (!defined $bowtie);
$fastx = which("fastx_clipper") if (!defined $fastx);
$samtools = which("samtools") if (!defined $samtools);

##
# Input validation
##

die "\n  [!] Error: No sample FastQ (or SAM/BAM) file provided\n\n" if (!@ARGV);
die "\n  [!] Error: No value specified for 3'-end trimming\n\n" if (!defined $trim3);
die "\n  [!] Error: 5'-end trimming value must be a positive integer\n\n" if ($trim5 < 0);
die "\n  [!] Error: 3'-end trimming value must be a positive integer\n\n" if ($trim3 < 0);
die "\n  [!] Error: Bowtie mismatches value must be an integer comprised between 0 and 3\n\n" if ((defined $bv &&
                                                                                                   $bv !~ m/^[0-3]$/) ||
                                                                                                  (defined $bn &&
                                                                                                   $bn !~ m/^[0-3]$/));
die "\n  [!] Error: Bowtie threads value must be an integer greater than 0\n\n" if (!isint($bp) ||
                                                                                    $bp < 1);
die "\n  [!] Error: No adapter's sequence provided\n\n"if (!defined $fa);
die "\n  [!] Error: Invalid adapter's sequence\n\n" if (!isdna($fa));
die "\n  [!] Error: No FastQ quality scale provided\n\n" if (!defined $fq);
die "\n  [!] Error: FastQ quality scale can be 33 or 64\n\n" if ($fq !~ m/^33|64$/);
die "\n  [!] Error: No minimum read length provided\n\n" if (!defined $fl);
die "\n  [!] Error: Minimum read length should be an integer >= 25\n\n" if ($fl < 25);
die "\n  [!] Error: Parameters -ba and -bm are mutually exclusive\n\n" if ($bm > 1 &&
                                                                           $ba);
die "\n  [!] Error: Parameter -n requires parameter -k\n\n" if ($nobam &&
                                                                !$keep);
die "\n  [!] Error: Invalid format for -t5 parameter's argument\n\n" if (defined $bam_trim5 &&
                                                                         $bam_trim5 !~ m/^(\d+[;,]?)+$/);
die "\n  [!] Error: Number of processors must be an integer greater than 0\n\n" if ($threads < 1);
warn "\n  [!] Warning: Some input files are duplicates. Considering only unique files...\n" if (@ARGV != uniq(@ARGV));

if (!defined $samtools) { die "\n  [!] Error: SAMTools is not in PATH\n\n"; }
elsif (!-e $samtools) { die "\n  [!] Error: SAMTools doesn't exist\n\n"; }
elsif (!-x $samtools) { die "\n  [!] Error: SAMTools is not executable\n\n"; }
else {
    
    my $ret = `$samtools 2>&1`;
    
    if ($ret =~ m/Version: (.+)$/m) {
        
        my $version = $1;
        
        die "\n  [!] Error: RT Count requires SAMTools v1 or greater (Detected: v" . $version . ")\n\n" if (substr($version, 0, 1) < 1);
        
    }
    else { warn "\n  [!] Warning: Unable to detect SAMTools version\n"; }
    
}

$SIG{__DIE__} = \&cleanup;

print "\n[+] Making output directory...";

if (-e $output) {

    if ($overwrite) {
        
        rmtree($output, { safe      => 1,
                          keep_root => 0,
                          error     => \$error });
        
        die "\n\n  [!] Error: Unable to overwrite output directory (" . $error->[0]->{each(%{$error->[0]})} . ")\n\n" if (@{$error});
        
    }
    else { die "\n\n  [!] Error: Output directory already exists." .
               "\n      Please use -ow (or --overwrite) to overwrite output directory\n\n"; }
    
}

mkpath($output . ($nobam ? "SAM" : "BAM"), { mode  => 0755,
                                             error => \$error }) if ($keep);
mkpath($output . "counts", { mode  => 0755,
                             error => \$error }); 
    
die "\n\n  [!] Error: Unable to create output directory (" . $error->[0]->{each(%{$error->[0]})} . ")\n\n" if (@{$error});

if (!-e $tmpdir) {
    
    mkdir($tmpdir, 0755) or die "\n\n  [!] Error: Unable to create temporary directory\n\n";
    $madetmp = 1;
    
}
else { die "\n\n  [!] Error: The path to the specified temporary folder is not a directory\n\n" if (!-d $tmpdir); }

##
# Prepare files
##

$table = Term::Table->new(indent => 2);
$table->head("Sample", "Type", "5'-end trimming");

@bam_trim5 = split(/,/, $bam_trim5);

undef($bam_trim5);
$bam_trim5 = shift(@bam_trim5) if (@bam_trim5 == 1);        # If only one value for 5' trimming in SAM/BAM files has been specified,
                                                            # this is applied to all the passed SAM/BAM files

print "\n[+] Guessing file types:\n\n";

foreach my $sample (uniq(@ARGV)) {
    
    die "  [!] Error: Specified sample \"" . $sample . "\" file doesn't exist\n\n" if (!-e $sample);

    my $file = (fileparse($sample, qr/\.[^.]*/))[0];
    
    push(@tmp, { path  => $sample,
                 file  => $file,
                 type  => guess_type($sample),
                 trim5 => 0 });
    
    $spacer{$file} = length($file);
    
    # If only one value for 5' trimming in SAM/BAM files has been specified, this is applied to all the passed SAM/BAM files
    $tmp[-1]->{trim5} = $tmp[-1]->{type} eq "FastQ" ? $trim5 : ($bam_trim5 ? $bam_trim5 : shift(@bam_trim5));
    
    die "  [!] Error: Less 5'-end trimming values in -t5 list than provided SAM/BAM files\n\n" if (!defined $tmp[-1]->{trim5});
    die "  [!] Error: 5'-end trimming value must be a positive integer\n\n" if (!ispositive($tmp[-1]->{trim5}) ||
                                                                                !isint($tmp[-1]->{trim5}));
    
    $table->row($tmp[-1]->{file}, $tmp[-1]->{type}, $tmp[-1]->{trim5} . " nt");
    
    $fastq++ if ($tmp[-1]->{type} eq "FastQ");
    
}

%spacer = map { $_ => 1 + max(values %spacer) - $spacer{$_} } (keys %spacer);

die "  [!] Error: More 5'-end trimming values in -t5 list than provided SAM/BAM files\n\n" if (@bam_trim5);

$table->print();

print "\n";

# Check if we have a FASTA file with transcripts and all required tools

if ($fastq) {
    
    if (!defined $bowtie) { die "\n  [!] Error: Bowtie is not in PATH\n\n"; }
    elsif (!-e $bowtie) { die "\n  [!] Error: Bowtie doesn't exist\n\n"; }
    elsif (!-x $bowtie) { die "\n  [!] Error: Bowtie is not executable\n\n"; }
        
    if (!defined $fastx) { die "\n  [!] Error: FASTX Clipper is not in PATH\n\n"; }
    elsif (!-e $fastx) { die "\n  [!] Error: FASTX Clipper doesn't exist\n\n"; }
    elsif (!-x $fastx) { die "\n  [!] Error: FASTX Clipper is not executable\n\n"; }

    die "\n  [!] Error: No Bowtie index provided\n\n" if (!defined $bi);
    
    for(qw(.1.ebwt .2.ebwt .3.ebwt .4.ebwt
           .rev.1.ebwt .rev.2.ebwt)) { die "\n  [!] Error: Bowtie index file \"" . $bi . $_ . "\" doesn't exist\n\n" if (!-e $bi . $_); }
    
}
 
if (defined $multifasta &&
    !defined $bi) { die "\n  [!] Error: Provided FASTA file doesn't exist\n\n" if (!-e $multifasta); }
elsif (defined $bi) {
    
    if (!-e $bi . ".fa") {

        print "\n[+] Reference FASTA file is absent. Regenerating from Bowtie index...";
                  
        if (-e $bowtie . "-inspect" ||
            -x $bowtie . "-inspect") { system($bowtie . "-inspect " . $bi . " 2>/dev/null > " . $tmpdir . $tmp . "_tmp.fa"); }
        else { die "\n\n  [!] Error: bowtie-inspect doesn't exists, or is not in your Bowtie's path\n\n"; }
        
        print "\n[+] Sorting FASTA file...";
    
        system("awk 'BEGIN{RS=\">\"} NR>1 {gsub(\"\\n\", \"\\t\"); print \">\"\$0}' \"" . $tmpdir . $tmp . "_tmp.fa\"" .
               " | LC_ALL=C sort -T \"" . $tmpdir . "\" -t ' ' -k2,2 | awk '{sub(\"\\t\", \"\\n\"); gsub(\"\\t\", \"\"); print \$0}' > \"" . $bi . ".fa\"");
    
    }
    else { print "\n[+] Reference FASTA file is present. Skipping FASTA regeneration..."; }

    $multifasta = $bi . ".fa";
    
}
else { die "\n  [!] Error: No FASTA file or Bowtie index provided\n\n"; }

# Starts the process manager
$processmanager = Core::Process::Queue->new( processors => $threads,
                                             stderr     => "/dev/null" );

##
# FastQ processing
##

if ($fastq) { # Some of the provided files need to be mapped
    
    print "\n[+] Processing FastQ files...";

    if (!$clipped) {
    
        print "\n[+] Clipping adapter's sequence from sequencing reads...\n";
        
        $processmanager->onstart(sub { print "\n  [-] Processing sample \"" . $_[0] . "\"" . (" " x $spacer{$_[0]}) . "(PID: " . $_[1] . ")"; });
        
        foreach my $sample (@tmp) {
        
            next if ($sample->{type} ne "FastQ");
            
            $processmanager->enqueue( command => $fastx . " -a " . $fa . " -l " . $fl . " -M 10 -Q " . $fq . " -i " . $sample->{path} . " -o " . $tmpdir . $tmp . "_" . $sample->{file} . ".fq",
                                      id      => $sample->{file} );
        
            $sample->{path} = $tmpdir . $tmp . "_" . $sample->{file} . ".fq";
        
        }
        
        $processmanager->start();
        $processmanager->waitall();
        
        while (my $sample = $processmanager->dequeue()) { die "\n\n  [!] Error: Unable to perform adapter clipping on sample \"" . $sample->id() . "\"." .
                                                              "\n             Please check input file's format/quality and try again.\n\n" if ($sample->exitcode()); }
        
        print "\n";
    
    }
    else {
    
        print "\n[+] Input FastQ files are already clipped. Skipping adapter clipping...";
        
        foreach my $sample (@tmp) {
            
            next if ($sample->{type} ne "FastQ");
            
            system("ln -s " . File::Spec->rel2abs($sample->{path}) . " " . $tmpdir . $tmp . "_" . $sample->{file} . ".fq");
            
            $sample->{path} = $tmpdir . $tmp . "_" . $sample->{file} . ".fq";
            
        }
    
    }
    
    ##
    # Reads mapping
    ##
    
    print "\n[+] Mapping reads to transcriptome...\n";
    
    $processmanager->onstart(sub { print "\n  [-] Mapping sample \"" . $_[0] . "\"" . (" " x $spacer{$_[0]}) . "(PID: " . $_[1] . ")"; });
        
    foreach my $sample (@tmp) {
    
        next if ($sample->{type} ne "FastQ");
        
        $processmanager->enqueue( command => $bowtie . ($trim3 ? " -3 " . $trim3 . " " : " ") . ($trim5 ? " -5 " . $trim5 . " " : " ") . "-q " . (defined $bv ? "-v " . $bv : "-n " . $bn) . " --norc " .
                                                       ($ba ? "-a" : "-m " . $bm) . " --best --strata -p " . $bp . " --chunkmbs " . $bc . " -S \"" . $bi . "\" \"" . $sample->{path} . "\"" .
                                                       " | grep -v '4\t\\*\t0\t0' > \"" . $tmpdir . $tmp . "_" . $sample->{file} . ".sam\"",
                                  id      => $sample->{file},
                                  stderr  => $tmpdir . $tmp . "_" . $sample->{file} . "_mapping.log" );
    
    }
    
    $processmanager->start();
    $processmanager->waitall();
    
    while (my $sample = $processmanager->dequeue()) { die "\n\n  [!] Error: An error has occurred while mapping sample \"" . $sample->id() . "\" reads to transcriptome\n\n" if ($sample->exitcode()); }
    
    print "\n\n[+] Mapping statistics:\n";
    
    foreach my $sample (@tmp) {
        
        next if ($sample->{type} ne "FastQ");
        
        my ($mapped, $failed, $suppressed, $reported) = bowtie_log($tmpdir . $tmp . "_" . $sample->{file} . "_mapping.log");
        my $total = $mapped + $failed + $suppressed;
        
        die "\n  [!] All reads for sample \"" . $sample->{file} . "\" have failed to map." .
            "\n      Please check the transcriptome assembly and try again.\n\n" if ($mapped == 0);
        
        $mapped = sprintf("%.2f", $mapped / $total * 100) . "%";
        $failed = sprintf("%.2f", $failed / $total * 100). "%";
        $suppressed = sprintf("%.2f", $suppressed / $total * 100) . "%";
        
        print "\n  [*] Sample \"" . $sample->{file} . "\"" . (" " x $spacer{$sample->{file}}) . "[Mapped: " . $mapped . "; Failed: " . $failed . ($ba ? "]" : "; Suppressed: " . $suppressed . "]");
        
        $sample->{path} = $tmpdir . $tmp . "_" . $sample->{file}  . ".sam";
        
    }
    
    print "\n\n[+] Sorting " . ($nobam ? "SAM" : "BAM") . " files...\n";
    
    $processmanager->onstart(sub { print "\n  [-] Sorting sample \"" . $_[0] . ($nobam ? ".sam" : ".bam") . "\"" . (" " x $spacer{$_[0]}) . "(PID: " . $_[1] . ")"; });
    
    foreach my $sample (@tmp) {
        
        next if ($sample->{type} ne "FastQ");
        
        my $path = $keep ? $output . ($nobam ? "SAM/" : "BAM/") . $sample->{file} . ($nobam ? ".sam" : ".bam") : $tmpdir . $tmp . "_" . $sample->{file} . "_sorted.sam";
        
        $processmanager->enqueue( command => $samtools . " sort -O " . ($nobam ? "sam" : "bam") . " -T " . $tmpdir . $tmp . "_" . $sample->{file} . " -o " . $path . " " . $sample->{path},
                                  id      => $sample->{file} );
        
        $sample->{path} = $path;
        
    }
    
    $processmanager->start();
    $processmanager->waitall();
    
    while (my $sample = $processmanager->dequeue()) { die "\n\n  [!] Error: Unable to perform sorting on sample \"" . $sample->id() . "\"\n\n" if ($sample->exitcode()); }
    
    print "\n";
    
}

##
# FASTA Parsing
##

print "\n[+] Getting transcripts from reference, and building count table base structure...";

open(my $ch, ">:raw", $tmpdir . $tmp . "_base.rtc") or die "\n\n  [!] Error: Unable to write count table base structure (" . $! . ")\n\n";
open(my $ih, ">:raw", $output . "counts/" . "index.rti") or die "\n\n  [!] Error: Unable to write count table index (" . $! . ")\n\n";
select((select($ch), $|=1)[0]);
select((select($ih), $|=1)[0]);

my $io = Data::IO::Sequence->new(file => $multifasta);

while (my $entry = $io->read()) {
    
    $entry->unmask(); # Makes sequence uppercase
    
    my ($id, $sequence);
    $id = $entry->id();
    
    $sequence = join("", map{sprintf("%x", $bases{$_})} split(//, $entry->sequence()));
    
    # Store length and offset for later steps
    # The offset is already positioned to the right byte to overwrite the zeros array
    $transcripts{$id} = { length => length($sequence),
                          offset => $offset + (4 * 2) + length($id) + 1 + (length($sequence) + (length($sequence) % 2)) / 2 };             
    
    print $ih pack("L<", length($id) + 1) .                 # len_transcript_id (uint32_t)
              $id . "\0" .                                  # transcript_id (char[len_transcript_id])
              pack("L<", $offset);                          # offset in count table (uint32_t)
    
    print $ch pack("L<", length($id) + 1) .                  # len_transcript_id (uint32_t)
              $id . "\0" .                                   # transcript_id (char[len_transcript_id])
              pack("L<", length($sequence)) .                # len_seq (uint32_t)
              pack("H*", $sequence) .                        # seq (uint8_t[(len_seq+1)/2])
              pack("L<*", (0) x (length($sequence) * 2));    # stops, cov (uint32_t[len_seq x 2])
              
    $offset += 4 * (length($sequence) * 2 + 2) + length($id) + 1 + (length($sequence) + (length($sequence) % 2)) / 2;
    
}

print $ch "\x5b\x65\x6f\x66\x72\x74\x63\x5d"; # EOF Marker

close($ih);
close($ch);

##
# SAM/BAM Header validation
##

print "\n[+] Validating SAM/BAM file headers...";

foreach my $sample (@tmp) {
        
    next if ($sample->{type} eq "FastQ"); # We can skip checking on files provided as FastQ, since they have been mapped using the right reference
    
    my $inheader = 0;
    
    open(my $fh, $samtools . " view -H " . $sample->{path} . " 2>&1 |") or die "\n\n  [!] Error: Unable to read SAM/BAM header from sample \"" . $sample->{file} . "\" (" . $! . ")\n\n";
    while (my $row = <$fh>) {
    
        chomp($row); 
    
        if ($row =~ m/^\@SQ\tSN:(.+?)\tLN:(\d+)$/) {
            
            my ($id, $length) = ($1, $2);
            
            die "\n\n  [!] Error: Transcript \"" . $id . "\" length from sample \"" . $sample->{file} . "\" header (" . $length . " nt) differs from reference (" . $transcripts{$id}->{length} . " nt)." .
                "\n             Please re-map your dataset using the same reference, and try again.\n\n" if (exists $transcripts{$id} &&
                                                                                                             $transcripts{$id}->{length} != $length);
                
            $inheader++;
            
        }
    
    }
    close($fh);
    
    warn "\n\n  [!] Warning: Only " . $inheader . "/" . keys(%transcripts) . " reference transcripts are present in sample \"" - $sample->{file} - "\" header." .
         "\n               All transcripts absent in reference will be skipped.\n\n" if ($inheader != keys(%transcripts));
         
    die "\n\n  [!] Error: All transcripts in sample \"" - $sample->{file} - "\" header are absent in reference." .
        "\n             Please re-map your dataset using the same reference, or provide a different reference by the -bi (or --bowtie-index) parameter.\n\n" unless($inheader);
    
}

##
# Sorting remaining SAM/BAM files (if needed)
##

if ($fastq < @tmp) {

    if ($sorted) {
        
        print "\n[+] Assuming that remaining SAM/BAM files are already sorted. Skipping sorting...";
        
        if ($keep &&
            !$nobam) {
            
            print "\n[+] Converting remaining SAM files (if any) to BAM format...\n";
            
            $processmanager->onstart(sub { print "\n  [-] Converting sample \"" . $_[0] . ".sam\" to BAM format" . (" " x $spacer{$_[0]}) . "(PID: " . $_[1] . ")"; });
            
            foreach my $sample (@tmp) {
            
                next if ($sample->{type} ne "SAM");
                
                my $path = $output . "BAM/" . $sample->{file} . ".bam";
                
                $processmanager->enqueue( command => $samtools . " view -b -o " . $path . " " . $sample->{path},
                                          id      => $sample->{file} );

                $sample->{path} = $path;
                
                $processmanager->start() and $sample->{path} = $path and next;
                
            }
            
            $processmanager->start();
            $processmanager->waitall();
    
            while (my $sample = $processmanager->dequeue()) { die "\n\n  [!] Error: Unable to perform conversion on sample \"" . $sample->id() . "\"\n\n" if ($sample->exitcode()); }
            
            print "\n";
            
        }
        
    }
    else {
        
        print "\n[+] Sorting remaining SAM/BAM files...\n";
        
        $processmanager->onstart(sub { print "\n  [-] Sorting sample \"" . $_[0] . ($nobam ? ".sam" : ".bam") . "\"" . (" " x $spacer{$_[0]}) . "(PID: " . $_[1] . ")"; });
        
        foreach my $sample (@tmp) {
            
            next if ($sample->{type} eq "FastQ");
            
            my $path = $keep ? $output . ($nobam ? "SAM/" : "BAM/") . $sample->{file} . ($nobam ? ".sam" : ".bam") : $tmpdir . $tmp . "_" . $sample->{file} . "_sorted.sam";
            
            $processmanager->enqueue( command => $samtools . " sort -O " . ($nobam ? "sam" : "bam") . " -T " . $tmpdir . $tmp . "_" . $sample->{file} . " -o " . $path . " " . $sample->{path},
                                      id      => $sample->{file} );

            $sample->{path} = $path;
            
        }
        
        $processmanager->start();
        $processmanager->waitall();
        
        while (my $sample = $processmanager->dequeue()) { die "\n\n  [!] Error: Unable to perform sorting on sample \"" . $sample->id() . ($nobam ? ".sam" : ".bam") . "\"\n\n" if ($sample->exitcode()); }
        
        print "\n";
        
    }

}

print "\n[+] Calculating per-base RT-stops and coverage. This may take a while...\n";

$qcounter = Thread::Queue->new();
$qresults = Thread::Queue->new();

@pool = map{ threads->create(\&count, $qcounter, $qresults) } 1 .. $threads;

$qcounter->enqueue($_) for (@tmp);
$qcounter->enqueue((undef) x $threads);

$_->join() for(@pool);

print "\n\n[+] Statistics:\n";

for (1 .. $threads) { while (my $result = $qresults->dequeue()) { print $result; } }

print "\n\n[+] Cleaning up temporary files...";

cleanup();

print "\n[+] All done.\n\n";

sub count {
    
    my ($qcounter, $qresults) = @_;
    
    while (my $sample = $qcounter->dequeue()) {
    
        my ($lastid, $covered, @stops, @coverage);
        $covered = 0;
        
        { lock($lock);
          print "\n  [-] Processing sample \"" . $sample->{file} . "\"" . (" " x $spacer{$sample->{file}}) . "(Thread #" . threads->tid . ")..."; }
        
        copy($tmpdir . $tmp . "_base.rtc", $output . "counts/" . $sample->{file} . ".rtc") or $qresults->enqueue("\n  [!] Error: Unable to copy counts table structure for sample \"" .
                                                                                                                 $sample->{file} . "\" (" . $! . ")") and next;
        
        # It is necessary to open the filehandle in read/write mode (+<) instead of append (>>)
        # See POSIX open(2) documentation, O_APPEND: "Before each write(2), the file offset is positioned at the end of the file, as if with lseek(2)".
        open(my $ch, "+<:raw", $output . "counts/" . $sample->{file} . ".rtc") or $qresults->enqueue("\n  [!] Error: Unable to write count table for sample \"" .
                                                                                                     $sample->{file} . "\" (" . $! . ")") and next;
        select((select($ch), $|=1)[0]);
        
        open(my $fh, $samtools . " view " . $sample->{path} . " |") or $qresults->enqueue("\n  [!] Error: Unable to read from sample \"" .
                                                                                          $sample->{file} . "\" (" . $! . ")") and next;
        while (!eof($fh)) {
            
            my $row = <$fh>;
            chomp($row);
            my @row = split(/\t/, $row);
            
            next if (!exists $transcripts{$row[2]});
            next if ($row[1] & 16); # Libraries should be stranded, so all reads should map to the forward strand
            
            if ($row[2] ne $lastid) {
                
                if (defined $lastid) {
                
                    seek($ch, $transcripts{$lastid}->{offset}, SEEK_SET);
                
                    # Overwrites the previously stored 0s with actual values
                    print $ch pack("L<*", @stops, @coverage);
                    
                    $covered++;
                    
                }
                
                $lastid = $row[2];
                @stops = (0) x $transcripts{$row[2]}->{length};
                @coverage = (0) x $transcripts{$row[2]}->{length};
                
            }
            
            if ($row[3] >= 2 + $sample->{trim5}) {
    
                $row[3] -= $sample->{trim5};
                $stops[($row[3] - 2)]++;
                
                map {$coverage[$_]++} ($row[3] - 2 < 0 ? 0 : $row[3] - 2) ..
                                       ($row[3] + length($row[9]) - 1 > $transcripts{$row[2]}->{length} - 1 ? $transcripts{$row[2]}->{length} - 1 : $row[3] + length($row[9]) - 1);
    
                #for my $i ($row[3] - 2 .. $row[3] + length($row[9]) - 1) {
                #
                #    next if ($i < 0);                                       # In case the actual 5'-end of transcript starts before the annotated one
                #    last if ($i > $transcripts{$row[2]}->{length} - 1);     # In case the actual 3'-end of transcript ends after the annotated one
                #
                #    $coverage[$i]++;
                #
                #}
    
            }
            
        }
        
        # Writes the last entry after EOF has been reached
        if (defined $lastid) {
        
            seek($ch, $transcripts{$lastid}->{offset}, SEEK_SET);
            print $ch pack("L<*", @stops, @coverage);
            
            $covered++;
            
        }
        
        close($fh);
        close($ch);
        
        $qresults->enqueue("\n  [*] Sample \"" . $sample->{file} . "\":" . (" " x $spacer{$sample->{file}}) . $covered . " transcripts covered");
        
    }
    
    $qresults->enqueue(undef);
    
    threads->exit();
    
}

sub cleanup {
    
    unlink(glob($tmpdir . $tmp . "*"));
    
    rmtree($tmpdir, { safe      => 1,
                      keep_root => 0,
                      error     => \$error }) if ($madetmp);
    
}

sub bowtie_log { 
    
    my $log = shift;
    
    my ($mapped, $failed, $suppressed, $reported) = (0, 0, 0, 0);
    
    open(my $fh, "<", $log) or die "\n  [!] Error: Unable to open Bowtie log file (" . $! . ")\n\n";
    while(my $row = <$fh>) {
        
        if ($row =~ m/reads with at least one reported alignment: (\d+) /) { $mapped = $1; }
        elsif ($row =~ m/reads that failed to align: (\d+) /) { $failed = $1; }
        elsif ($row =~ m/reads with alignments suppressed due to -m: (\d+) /) { $suppressed = $1; }
        elsif ($row =~ m/Reported (\d+) alignments to 1 output stream/) { $reported = $1; }
        
    }
    close($fh);
    
    return($mapped, $failed, $suppressed, $reported);
    
}

sub guess_type {
    
    my $file = shift;
    
    my ($type);
    
    if ($file =~ m/\.(fq|fastq)$/i) { $type = "FastQ"; }
    elsif ($file =~ m/\.([bs]am)$/i) { $type = uc($1); }
    else {
    
        my (@rows);
    
        open(my $fh, "<" . $file) or die "\n  [!] Error: Unable to open sample \"" . $file . "\" (" . $! . ")\n\n";
        for (0 .. 3) { $rows[$_] = <$fh>; }
        close($fh);
        
        if ($rows[0] =~ m/^@/ &&
            isdna($rows[1]) &&
            $rows[2] =~ m/^\+/) { $type = "FastQ"; }
        else {
            
            my ($header, $eof, @data);
            $header = "\x1f\x8b\x08\x04\x00\x00\x00\x00\x00\xff\x06\x00\x42\x43\x02\x00";
            $eof = "\x1f\x8b\x08\x04\x00\x00\x00\x00\x00\xff\x06\x00BC\x02\x00\x1b\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00";
            
            open(my $fh, $samtools . " view " . $file . " 2>&1|");
            for (1 .. 10) {
                
                my ($row, @row);
                
                $row = <$fh>;
                @row = split("\t", $row);
                
                die "\n  [!] Error: Sample \"" . $file . "\" is not a valid FastQ/SAM/BAM file\n\n" if (@row < 12 ||
                                                                                                        !isint($row[3]) ||
                                                                                                        !isdna($row[9]));
                
            }
            close($fh);
            
            open($fh , "<:raw", $file);
            read($fh, $data[0], 16);
            seek($fh, -28, SEEK_END);
            read($fh, $data[1], 28);
            close($fh);
            
            if ($data[0] eq $header &&
                $data[1] eq $eof) { $type = "BAM"; }
            else { $type = "SAM";}
            
        }
    
    }
    
    return($type);
    
}

sub help {
    
    print "\n  [!] Error: Invalid option. Please check the help\n" if ($_[0]);
    
    die <<HELP;
 
 RT Count (v1.0.0a)
 Epigenetics Units @ HuGeF [Human Genetics Foundation]
 Group leader: Prof. Salvatore Oliviero
    
 Author:  Danny Incarnato (danny.incarnato[at]hugef-torino.org)
 Summary: Performs reads mapping, and calculates per-base RT-stops and coverage
 
 Usage:   rt-count [Options] Sample1.fastq Sample2.sam Sample3.bam ... Samplen.fastq
 
 Options                             Description
 -p  or --processors                 Number of processors to use (Default: 1)
 -t  or --tmp-dir                    Temporary directory (Default: /tmp)
 -o  or --output-dir                 Output directory (Default: rt_count/)
 -ow or --overwrite                  Overwrites output directory (if the specified path already exists)
 -k  or --keep                       Keeps SAM/BAM files after reads mapping.
                                     Note: If input files are in SAM format, and the -n option has not been specified,
                                           this causes the SAM files to be converted to BAM format.
 -n  or --no-bam                     Disables mapped SAM files conversion to BAM format (requires -k)
 -b  or --bowtie                     Path to Bowtie v1 executable (Default: assumes Bowtie is in PATH)
 -fx or --fastx                      Path to FASTX Clipper executable (Default: assumes FASTX Clipper is in PATH)
 -s  or --samtools                   Path to SAMTools executable (Default: assumes SAMTools is in PATH)
 -r  or --sorted                     Assumes that the provided SAM/BAM files are already sorted lexicographically by
                                     transcript ID, and numerically by position
 -t5 or --trim-5prime                In the case that SAM/BAM files are provided, this allows to specify a comma separated
                                     list (no spaces) of values indicating the number of bases trimmed from the 5'-end of
                                     reads in the respective sample SAM/BAM files (Default: 0).
                                     Note: Values must be provided in the same order as the input files.
                                           If a single value is specified along with multiple SAM/BAM files, it will
                                           be used for all files.
 -f  or --fasta                      Path to a FASTA file containing the reference transcripts
                                     Note: Transcripts in this file must match transcripts in SAM/BAM file headers.
                                           This can be omitted if a Bowtie index is specified by -bi (or --bowtie-index).
 
 FASTX Clipper options
 -fa or --fastx-adapter              Sequence of 3' adapter for clipping (Default: TGGAATTCTCGGGTGCCAAGG)
 -fq or --fastx-qual                 FastQ files quality scale (33 [Default], or 64)
 -fl or --fastx-len                  Minimum length to keep reads after clipping (>=35, Default: 35)
 -c  or --clipped                    Assumes that the provided FastQ files have been already clipped
 
 Bowtie options
 -bn or --bowtie-n                   Use Bowtie mapper in -n mode (0-3 mismatches, Default: 2)
 -bv or --bowtie-v                   Use Bowtie mapper in -v mode (0-3 mismatches, Default: disabled)
 -bm or --bowtie-max                 Report up to this number of equally scoring positions for multi-mapping reads
                                     (Default: 1, reports only uniquelly mapped reads)
 -ba or --bowtie-all                 Report all equally scoring positions for multi-mapping reads
                                     (Default: disabled, reports only uniquely mapped reads)
 -b5 or --bowtie-trim-5prime         Number of bases to trim from 5'-end of the read (0-5 bases, Default: 0)
 -b3 or --bowtie-trim-3prime         Number of bases to trim from 3'-end of the read (0-15 bases, Default: 0)
 -bc or --bowtie-chunkmbs            Maximum MB of RAM for best-first search frames (Default: 128)
 -bp or --bowtie-threads             Number of threads to use for each instance of Bowtie (Default: 1).
                                     Note: RT Counter executes 1 instance of Bowtie for each processor specified by -p.
                                           At least -p <processors> * bowtie-threads processors are required.
 -bi or --bowtie-index               Path to transcriptome reference index
 
 
HELP
    
}

