#!/usr/bin/perl

##
# RSF Silico (v1.1.0)
# Epigenetics Unit @ HuGeF [Human Genetics Foundation]
#
# Author:  Danny Incarnato (danny.incarnato[at]hugef-torino.org)
# Summary: Produces SPD files using the probability of bases of being unpaired
#
# This program is free software, and can be redistribute  and/or modified
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# Please see <http://www.gnu.org/licenses/> for more informations.
##

use strict;
use Config;
use Cwd;
use File::Path qw(mkpath rmtree);
use FindBin qw($Bin);
use Getopt::Long qw(:config no_ignore_case);
use threads;
use threads::shared;
use Thread::Queue;

use lib $Bin . "/lib";

use Core::Utils;
use Core::Mathematics qw(:all);
use Data::IO::Sequence;
use Data::IO::XML;
use Data::Sequence::Utils;
use Term::Constants qw(:screen);

die "\n  [!] Error: This program requires ithreads." .
    "\n             Please recompile Perl with ithreads and try again\n\n" unless(exists $Config{useithreads});

$|++;

my ($tmp, $tmpdir, $multifasta, $t,
    $io, $window, $offset, $decimals,
    $output, $overwrite, $help, $error,
    $viennarna, $partition, $data, $maxdist,
    $probplot, $method, $madetmp, $keepbases,
    $threads, $queue, @pool);
$t = 37.0;
$tmp = randalphanum(0xf);
$tmpdir = "/tmp/";
$decimals = 3;
$window = 1e9;
$offset = 1e9;
$maxdist = 0;
$madetmp = 0;
$method = 1;
$threads = 1;
$keepbases = "N";
$output = "rsf-silico/";

my %results : shared;
%results = ( folded => 0,
             failed => 0 );

do {
    
    local $SIG{__WARN__} = sub { };

    GetOptions( "h|help"                => \$help,
                "f|fasta=s"             => \$multifasta,
                "t|tmp-dir=s"           => \$tmpdir,
                "p|processors=i"        => \$threads,
                "e|temperature=s"       => \$t,
                "w|window-size=i"       => \$window,
                "wo|window-offset=i"    => \$offset,
                "o|output-dir=s"        => \$output,
                "d|decimals=i"          => \$decimals,
                "ow|overwrite"          => \$overwrite,
                "md|maximum-distance=i" => \$maxdist,
                "v|viennarna=s"         => \$viennarna,
                "pt|partition=s"        => \$partition,
                "pp|probability-plot=s" => \$probplot,
                "dp|data-path=s"        => \$data ,
                "m|method=i"            => \$method,
                "kb|keep-bases=s"       => \$keepbases ) or help(1);

};

help() if ($help);

$viennarna = which("RNAfold") if (!defined $viennarna);
$partition = which("partition-smp") || which("partition") if (!defined $partition);
$probplot = which("ProbabilityPlot") if (!defined $probplot);
$data = $ENV{DATAPATH} if (!defined $data);

die "\n  [!] Error: No FASTA file provided\n\n" unless(defined $multifasta);
die "\n  [!] Error: Provided FASTA file doesn't exist\n\n" unless(-e $multifasta);
die "\n  [!] Error: Number of processors must be an integer greater than 0\n\n" if ($threads < 1);
die "\n  [!] Error: Temperature must be a positive value\n\n" unless(ispositive($t));
die "\n  [!] Error: Temperature must be comprised between 0 and 100 degree Celsius\n\n" if ($t > 100);
die "\n  [!] Error: Decimals value must be an integer comprised between 1 and 10\n\n" if ($decimals < 1 ||
                                                                                          $decimals > 10);
die "\n  [!] Error: Window's size must be an integer >= 3\n\n" if (!isint($window) &&
                                                                   $window < 3);
die "\n  [!] Error: Window's offset must be an integer >= 1\n\n" if ($offset < 1);
die "\n  [!] Error: Window's offset cannot exceed window's size\n\n" if ($offset > $window);
die "\n  [!] Error: Maximum distance value must be a positive integer\n\n" if (!ispositive($maxdist));
die "\n  [!] Error: Invalid partition function calculation method\n\n" if ($method !~ m/^[1-3]$/);
die "\n  [!] Error: Invalid reactive bases\n\n" if ($keepbases !~ m/^all$/i &&
                                                    !isiupac($keepbases));

$output =~ s/\/?$/\//;
$keepbases = $keepbases =~ m/^all$/i ? "ACGT" : join("", sort(uniq(iupac2nt(rna2dna($keepbases)))));

$SIG{__DIE__} = \&cleanup;

print "\n[+] Checking method's requirements...";

if ($method =~ m/^[13]$/) { # ViennaRNA
    
    my $ret = `$viennarna --version`;
    
    if ($ret =~ m/RNAfold (\d+)\.(\d+)/) {
        
        my ($v1, $v2) = ($1, $2);
        
        die "\n\n  [!] Error: RSF Silico requires ViennaRNA package v2.2.0 or greater (Detected: v" . $v1 . "." . $v2 . ")\n\n" if ($v1 < 2 ||
                                                                                                                                    $v2 < 2);
        
    }
    else { warn "\n\n  [!] Warning: Unable to detect ViennaRNA package version\n"; }
    
}

if ($method =~ m/^[23]$/) { # RNAstructure

    if (!defined $data) { die "\n\n  [!] Error: Environment variable DATAPATH is not set\n\n"; }
    elsif (!-d $data) { die "\n\n  [!] Error: Provided DATAPATH directory doesn't exist\n\n"; }

    if (!defined $partition) { die "\n\n  [!] Error: RNAstructure Partition is not in PATH\n\n"; }
    elsif (!-e $partition) { die "\n\n  [!] Error: RNAstructure Partition doesn't exist\n\n"; }
    elsif (!-x $partition) { die "\n\n  [!] Error: RNAstructure Partition is not executable\n\n"; }
    
    if (!defined $probplot) { die "\n\n  [!] Error: RNAstructure ProbabilityPlot is not in PATH\n\n"; }
    elsif (!-e $probplot) { die "\n\n  [!] Error: RNAstructure ProbabilityPlot doesn't exist\n\n"; }
    elsif (!-x $probplot) { die "\n\n  [!] Error: RNAstructure ProbabilityPlot is not executable\n\n"; }

    $ENV{DATAPATH} = $data;

}

print "\n[+] Making output directory...";

if (-e $output) {

    if ($overwrite) {
        
        rmtree($output, { safe      => 1,
                          keep_root => 0,
                          error     => \$error });
        
        die "\n\n  [!] Error: Unable to overwrite output directory (" . $error->[0]->{each(%{$error->[0]})} . ")\n\n" if (@{$error});
        
        
        
    }
    else { die "\n\n  [!] Error: Output directory already exists." .
               "\n      Please use -ow (or --overwrite) to overwrite output directory\n\n"; }
    
}

mkpath($output, { mode  => 0755,
                  error => \$error }); 
    
die "\n\n  [!] Error: Unable to create output directory (" . $error->[0]->{each(%{$error->[0]})} . ")\n\n" if (@{$error});

if (!-e $tmpdir) {
    
    mkdir($tmpdir, 0755) or die "\n\n  [!] Error: Unable to create temporary directory\n\n";
    $madetmp = 1;
    
}
else { die "\n\n  [!] Error: The path to the specified temporary folder is not a directory\n\n" if (!-d $tmpdir); }

$io = Data::IO::Sequence->new(file => $multifasta);

print "\n[+] Calculating base-pairing probabilities [Last: none]";

$queue = Thread::Queue->new();
@pool = map{ threads->create(\&partcalc, $queue) } 1 .. $threads;

while(my $entry = $io->read()) { $queue->enqueue($entry); }

$queue->enqueue((undef) x $threads);
$_->join() for (@pool);

print "\n[+] Partition folding statistics:\n" .
      "\n  [*] Folded transcripts: " . $results{folded} .
      "\n  [*] Failed transcripts: " . $results{failed} . "\n";

print "\n[+] Cleaning up temporary files...";

cleanup();

print "\n[+] All done.\n\n";

sub partcalc {
    
    my $queue = shift;
    
    while(my $entry = $queue->dequeue()) {
    
        my ($id, $sequence, $len, $reactivity,
            $spd, $win, $off, $failed, @bppm);
        $id = $entry->id();
        $sequence = $entry->sequence();
        $len = length($sequence);
        $win = $window > $len ? $len : $window;
        $off = $win == $len ? $win : $offset;
        
        for(my $i = 0; $i + $win - 1 < $len; $i += $off) {
            
            my ($subseq, @window);
            $subseq = substr($sequence, $i, $win);
            @window = partition($id, $subseq);
            
            if (!@window) {
                
                lock(%results);
                $results{failed}++;
                $failed = 1;
                
            }
            
            for (0 .. $#window) { push(@{$bppm[$_ + $i]}, $window[$_]); }
            
        }
        
        next if ($failed);
        
        if (@bppm < $len) {
            
            my ($subseq, $i, @window);
            $i = $len - $win;
            $subseq = substr($sequence, $i);
            @window = partition($id, $subseq);
            
            if (!@window) {
                
                lock(%results);
                $results{failed}++;
                $failed = 1;
                
            }
            
            for (0 .. $#window) { push(@{$bppm[$_ + $i]}, $window[$_]); }
            
            
        }
        
        next if ($failed);
        
        @bppm = map { mean(@{$_}) } @bppm;
        undef($bppm[$-[0]]) while($sequence =~ m/[^$keepbases]/g);
        $reactivity = join(",", map { defined $_ ? sprintf("%." . $decimals . "f", $_) : "NaN" } @bppm);
            
        # For nicer formatting
        $sequence =~ s/(\w{60})/$1\n/g;
        $reactivity =~ s/((?:[\w\.]+,){60})/$1\n/g;
        
        $spd = Data::IO::XML->new( file      => $output . $id . ".spd",  
                                   mode      => "w",
                                   heading   => 1,
                                   indent    => 0,
                                   autoclose => 1,
                                   verbosity => -1 );
        
        $spd->opentag("data", { reactive => $keepbases,
                                offset   => $off,
                                win      => $win });
        $spd->opentag("transcript", { id     => $id,
                                      length => $len });
        $spd->opentag("sequence");
        $spd->addtext($sequence);
        $spd->closelasttag();
        $spd->opentag("reactivity");
        $spd->addtext($reactivity);
        $spd->write();
        
        { lock(%results);
          $results{folded}++;
          
          print CLRRET . "[+] Calculating base-pairing probabilities [Last: $id]"; }
    
    }
    
}

sub partition {
    
    my ($id, $winseq) = @_;
    
    my ($cwd, $ret, $cmd, $tmpseq,
        $tmpid, @vienna, @rnastructure, @mean);
    $cwd = cwd();
    $tmpid = $tmp . "_" . $id;
    $tmpseq = $tmpid . ".fa";
    @vienna = (0) x length($winseq) if ($method =~ m/^[13]$/);
    @rnastructure = (0) x length($winseq) if ($method =~ m/^[23]$/);
    
    chdir($tmpdir);
    
    # Writes temporary sequence
    open(my $wh, ">", $tmpseq) or return();
    print $wh ">" . $tmpid . "\n" . $winseq;
    close($wh);
    
    if ($method =~ m/^[13]$/) { # ViennaRNA
    
        $cmd = $viennarna . " -p -i " . $tmpseq . " -T " . $t;
        $cmd .= " --maxBPspan=" . $maxdist if ($maxdist);
        $ret = `$cmd --noPS 2>&1`;
        
        open(my $fh, "<", $tmpid . "_dp.ps") or return();
        while(<$fh>) {
            
            if ($_ =~ m/^(\d+) (\d+) ([\d\.]+) ubox$/) {
                
                my ($i, $j, $p) = ($1, $2, $3);
                
                $p = $p ** 2;       # ViennaRNA returns sqrt(p(i,j))
                $vienna[$i-1] += $p;
                $vienna[$j-1] += $p;
                
            }
            
        }
        close($fh);
        
    }
    
    if ($method =~ m/^[23]$/) { # RNAstructure
        
        my $pfs = $tmp . "_" . $id . ".pfs";
        $cmd = $partition . " " . $tmpseq . " " . $pfs;
        $cmd .= " -t " . ($t + 273.15);
        $cmd .= " -md " . $maxdist if ($maxdist);
        $ret = `$cmd 2>&1`;
        
        return() if ($ret !~ m/Single strand partition function complete\./);
        
        $cmd = $probplot . " -t " . $pfs . " " . $pfs . ".txt";
        $ret = `$cmd 2>&1`;
        
        return() if ($ret !~ m/Probability dot plot complete\./);
        
        open(my $fh, "<", $pfs . ".txt") or return();
        while(<$fh>) {
            
            if ($_ =~ m/^(\d+)\t(\d+)\t([\d\.]+)$/) {
                
                my ($i, $j, $p) = ($1, $2, $3);
                
                $p = 10 ** (-$p);      # ProbabilityPLot returns -log10(p(i,j))
                $rnastructure[$i-1] += $p;
                $rnastructure[$j-1] += $p;
                
            }
            
        }
        close($fh);
        
    }
    
    unlink(glob($tmp . "_" . $id . "*"));
    
    chdir($cwd);
    
    if ($method == 1) { @mean = map { 1 - $_ } @vienna; } 
    elsif ($method == 2) { @mean = map { 1 - $_ } @rnastructure; }
    else { @mean = map { 1 - mean($vienna[$_], $rnastructure[$_]) } (0 .. $#vienna); }
    
    return(@mean);
    
}

sub cleanup {
    
    if ($madetmp) {
    
        rmtree($tmpdir, { safe      => 1,
                          keep_root => 0,
                          error     => \$error });
        
    }
    else { unlink(glob($tmpdir . $tmp . "*")); }
    
}

sub help {
    
    print "\n  [!] Error: Invalid option. Please check the help\n" if ($_[0]);
    
    die <<HELP;
 
 RSF Silico (v0.1.0)
 Epigenetics Units @ HuGeF [Human Genetics Foundation]
 Group leader: Prof. Salvatore Oliviero
    
 Author:  Danny Incarnato (danny.incarnato[at]hugef-torino.org)
 Summary: Produces SPD files using the probability of bases of being unpaired
 
 Usage:   rsf-silico [Options]
 
 Options                             Description
 -f   or --fasta                     Path to a FASTA file containing transcript sequences
 -o   or --output-dir                Output directory (Default: rsf-silico/)
 -ow  or --overwrite                 Overwrites output directory (if the specified path already exists)
 -t   or --tmp-dir                   Temporary directory (Default: /tmp)
 -p   or --processors                Number of processors to use for the analysis (Default: 1)
 -m   or --method                    Partition function calculation method (Default: 1): [1] ViennaRNA
                                                                                         [2] RNAstructure
                                                                                         [3] Combined
                                     Note: method #3 calculates base-pair probabilities using both ViennaRNA and RNAstructure,
                                           and produces a SPD file containing the per-base average of the two methods
 -e   or --temperature               Temperature in Celsius degrees (Default: 37.0)
 -md  or --maximum-distance          Sets the maximum pairing distance in nucleotides between transcript's residues (Default: 0 [No limit])
 -v   or --viennarna                 Path to ViennaRNA RNAfold executable (Default: assumes RNAfold is in PATH)
 -pr  or --partition                 Path to RNAstructure Partition executable (Default: assumes Partition is in PATH)
 -pp  or --probability-plot          Path to RNAstructure ProbabilityPlot executable (Default: assumes ProbabilityPlot is in PATH)
 -dp  or --data-path                 Path to RNAstructure data tables (Default: assumes DATAPATH environment variable is already set)
 -w   or --window-size               Window for base-pair probability calculation (>=3, Default: full transcript)
 -wo  or --window-offset             Offset for window sliding (Default: none)
 -kb  or --keep-bases                Bases to report in the SPD file (Default: N)
                                     Note: excluded bases will be reported as NaN in the SPD file
 -d   or --decimals                  Number of decimals for reporting reactivities (1-10, Default: 3)
 
HELP
    
}
