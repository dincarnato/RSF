#!/usr/bin/perl

##
# RSF Analyzer (v0.1.0)
# Epigenetics Unit @ HuGeF [Human Genetics Foundation]
#
# Author:  Danny Incarnato (danny.incarnato[at]hugef-torino.org)
# Summary: Performs whole-transcriptome analysis and normalization of high-throughput
#          RNA structural probing data (CIRS-seq, SHAPE-seq, Structure-seq, and PARS)
#
# This program is free software, and can be redistribute  and/or modified
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# Please see <http://www.gnu.org/licenses/> for more informations.
##

# Sample #1: Non treated (chemical), RNAse V1 (enzymatic)
# Sample #2: DMS (chemical), Nuclease S1 (enzymatic)
# Sample #3: CMCT (CIRS-seq only)

use strict;
use Config;
use File::Basename;
use File::Path qw(rmtree);
use File::Spec;
use File::Which;
use FindBin qw($Bin);
use Getopt::Long qw(:config no_ignore_case);
use threads;

use lib $Bin . "/lib";

use Core::Mathematics qw(:all);
use Core::Statistics;
use Data::IO::Sequence;
use Data::Sequence::Utils;

die "\n  [!] Error: This program requires ithreads." .
    "\n             Please recompile Perl with ithreads and try again\n\n" unless(defined $Config{useithreads});

$|++;

my ($tmp, $tmpdir, $sample1, $sample2,
    $sample3, $output, $kn2, $kn3,
    $k2, $k3, $keep, $trim3,
    $trim5, $bv, $bn, $ba,
    $bp, $bi, $bc, $fa, $fq,
    $fl, $bowtie, $fastx, $samtools,
    $multifasta, $decimals, $avoid, $normmethod,
    $pseudocount, $sam, $sorted, $multimap,
    $rs, $enzymatic, $clipped, $nsamples,
    $scoringmethod, $normall, $help, $overwrite,
    @tmp, @pids, %n, %transcripts);

$tmp = int(rand(time())) + int(rand(time()));
$tmpdir = "/tmp/";
$output = "analyzer_out/";
$fa = "TGGAATTCTCGGGTGCCAAGG";
$fl = 35;
$fq = 33;
$trim5 = 0;
$trim3 = 0;
$decimals = 3;
$pseudocount = 1;
$normmethod = 1;
$scoringmethod = 1;
$bn = 2;
$rs = 1;
$bp = 1;
$bc = 128;

do {
    
    local $SIG{__WARN__} = sub { };

    GetOptions( "h|help"                => \$help,
                "1|sample1=s"           => \$sample1,
                "2|sample2=s"           => \$sample2,
                "3|sample3=s"           => \$sample3,
                "e|enzymatic"           => \$enzymatic,
                "a|avoid-non-canonical" => \$avoid,
                "t|tmp-dir=s"           => \$tmpdir,
                "o|output-dir=s"        => \$output,
                "ow|overwrite"          => \$overwrite,
                "k|keep-tmp"            => \$keep,
                "t5|trim-5prime=i"      => \$trim5,
                "t3|trim-3prime=i"      => \$trim3,
                "d|decimals=i"          => \$decimals,
                "p|pseudocount=i"       => \$pseudocount,
                "bv|bowtie-v=i"         => \$bv,
                "bn|bowtie-n=i"         => \$bn,
                "ba|bowtie-all"         => \$ba,
                "bp|bowtie-threads=i"   => \$bp,
                "bi|bowtie-index=s"     => \$bi,
                "bc|bowtie-chunkmbs=i"  => \$bc,
                "fa|fastx-adapter=s"    => \$fa,
                "fq|fastx-qual=i"       => \$fq,
                "fl|fastx-len=i"        => \$fl,
                "c|clipped"	        => \$clipped,
                "b|bowtie=s"            => \$bowtie,
                "f|fastx=s"             => \$fastx,
                "s|samtools=s"          => \$samtools,
                "nm|norm-method=i"      => \$normmethod,
                "na|norm-all"           => \$normall,
                "sm|scoring-method=i"   => \$scoringmethod,
                "mm|multi-mapping"      => \$multimap,
                "S|sam"                 => \$sam,
                "r|sorted"              => \$sorted,
                "rs|rt-stops=i"         => \$rs ) or help(1);

};

help() if ($help);

$tmpdir =~ s/\/?$/\//;
$output =~ s/\/?$/\//;
$bowtie = which("bowtie") if (!defined $bowtie);
$fastx = which("fastx_clipper") if (!defined $fastx);
$samtools = which("samtools") if (!defined $samtools);
$nsamples = defined $sample3 ? 3 : 2;

##
# Input validation
##

die "\n  [!] Error: No Sample #1 " . ($sam ? "SAM" : "FastQ") . " file provided\n\n" if (!defined $sample1);
die "\n  [!] Error: No Sample #2 " . ($sam ? "SAM" : "FastQ") . " file provided\n\n" if (!defined $sample2);
die "\n  [!] Error: Sample #1 " . ($sam ? "SAM" : "FastQ") . " file doesn't exist\n\n" if (!-e $sample1);
die "\n  [!] Error: Sample #2 " . ($sam ? "SAM" : "FastQ") . " file doesn't exist\n\n" if (!-e $sample2);
die "\n  [!] Error: Sample #3 " . ($sam ? "SAM" : "FastQ") . " file doesn't exist\n\n" if (defined $sample3 &&
                                                                                           !-e $sample3);
die "\n  [!] Error: Minimum RT-stops/Nuclease cuts value must be a positive value greater than 0\n\n" if (!ispositive($rs) ||
													  $rs == 0);
die "\n  [!] Error: No value specified for 3'-end trimming\n\n" if (!defined $trim3);
die "\n  [!] Error: No value specified for pseudocount\n\n" if (!defined $pseudocount);
die "\n  [!] Error: 5'-end trimming value must be an integer comprised between 0 and 5\n\n" if ($trim5 < 0 || $trim5 > 5);
die "\n  [!] Error: 3'-end trimming value must be an integer comprised between 0 and 15\n\n" if ($trim3 < 0 || $trim3 > 15);
die "\n  [!] Error: Decimals value must be an integer comprised between 1 and 10\n\n" if ($decimals < 1 || $decimals > 10);
die "\n  [!] Error: Pseudocount value must be an integer greater than 0\n\n" if ($pseudocount <= 0);
die "\n  [!] Error: Bowtie mismatches value must be an integer comprised between 0 and 3\n\n" if ((defined $bv &&
                                                                                                   $bv !~ m/^[0-3]$/) ||
                                                                                                  (defined $bn &&
                                                                                                   $bn !~ m/^[0-3]$/));
die "\n  [!] Error: Bowtie -n and -v parameters are mutually exclusive\n\n" if (defined $bn &&
                                                                                defined $bv);
die "\n  [!] Error: Bowtie threads value must be an integer greater than 0\n\n" if (!isint($bp) ||
                                                                                    $bp <= 0);
die "\n  [!] Error: No Bowtie index provided\n\n" if (!defined $bi);

for(qw(.1.ebwt .2.ebwt .3.ebwt .4.ebwt
       .rev.1.ebwt .rev.2.ebwt)) { die "\n  [!] Error: Bowtie index file \"" . $bi . $_ . "\" doesn't exist\n\n" if (!-e $bi . $_); }

die "\n  [!] Error: No adapter's sequence provided\n\n"if (!defined $fa);
die "\n  [!] Error: Invalid adapter's sequence\n\n" if (!isdna($fa));
die "\n  [!] Error: No FastQ quality scale provided\n\n" if (!defined $fq);
die "\n  [!] Error: FastQ quality scale can be 33 or 64\n\n" if ($fq !~ m/^33|64$/);
die "\n  [!] Error: No minimum read length provided\n\n" if (!defined $fl);
die "\n  [!] Error: Minimum read length should be an integer >= 25\n\n" if ($fl < 25);
die "\n  [!] Error: No normalization method specified\n\n" if (!$normmethod);
die "\n  [!] Error: Invalid normalization method\n\n" if ($normmethod !~ m/^[1-3]$/);
die "\n  [!] Error: No scoring method specified\n\n" if (!$scoringmethod);
die "\n  [!] Error: Invalid scoring method\n\n" if ($scoringmethod !~ m/^[1-2]$/);
die "\n  [!] Error: Parameter -mm (--multi-mapping) requires -ba (--bowtie-all)\n\n" if (($multimap &&
                                                                                         !$ba) &&
                                                                                         !$sam);
die "\n  [!] Error: Parameter -a (--avoid-non-canonical) doesn't apply to enzymatic probing\n\n" if ($avoid &&
												     $enzymatic);

if (!defined $bowtie) { die "\n  [!] Error: Bowtie is not in PATH\n\n"; }
elsif (!-e $bowtie) { die "\n  [!] Error: Bowtie doesn't exist\n\n"; }
elsif (!-x $bowtie) { die "\n  [!] Error: Bowtie is not executable\n\n"; }
    
if (!defined $fastx) { die "\n  [!] Error: FASTX Clipper is not in PATH\n\n"; }
elsif (!-e $fastx) { die "\n  [!] Error: FASTX Clipper doesn't exist\n\n"; }
elsif (!-x $fastx) { die "\n  [!] Error: FASTX Clipper is not executable\n\n"; }

if (!defined $samtools) { die "\n  [!] Error: SAMTools is not in PATH\n\n"; }
elsif (!-e $samtools) { die "\n  [!] Error: SAMTools doesn't exist\n\n"; }
elsif (!-x $samtools) { die "\n  [!] Error: SAMTools is not executable\n\n"; }

$SIG{__DIE__} = \&cleanup;

if (!-e $bi . ".fa") {

    print "\n[+] Reference FASTA file is absent. Regenerating from Bowtie index...";
              
    if (-e $bowtie . "-inspect" ||
        -x $bowtie . "-inspect") { system($bowtie . "-inspect " . $bi . " 2>/dev/null > " . $tmpdir . $tmp . "_tmp.fa"); }
    else { die "\n\n  [!] Error: bowtie-inspect doesn't exists, or is not in your Bowtie's path\n\n"; }
    
    print "\n[+] Sorting FASTA file...";

    system("awk 'BEGIN{RS=\">\"} NR>1 {gsub(\"\\n\", \"\\t\"); print \">\"\$0}' \"" . $tmpdir . $tmp . "_tmp.fa\"  | LC_ALL=C sort -T \"" . $tmpdir . "\" -t ' ' -k2,2 | awk '{sub(\"\\t\", \"\\n\"); gsub(\"\\t\", \"\"); print \$0}' > \"" . $tmpdir . $tmp . ".fa\"");
    $multifasta = $tmpdir . $tmp . ".fa";

}
else {

    print "\n[+] Reference FASTA file is present. Skipping FASTA regeneration...";    
    $multifasta = $bi . ".fa";
    
}

print "\n[+] Making output directory...";

if (-e $output) {

    my ($error);

    if ($overwrite) {
        
        rmtree($output, { safe      => 1,
                          keep_root => 1,
                          error     => \$error });
        
        die "\n\n  [!] Error: Unable to overwrite output directory (" . $error->[0] . ")\n\n" if (@{$error});
        
        
        
    }
    else { die "\n\n  [!] Error: Output directory already exists." .
               "\n      Please use -ow (or --overwrite) to overwrite output directory\n\n"; }
    
}
else { mkdir($output, 0755) or die "\n\n  [!] Error: Unable to create temporary directory\n\n"; }

if (!-e $tmpdir) { mkdir($tmpdir, 0755) or die "\n\n  [!] Error: Unable to create temporary directory\n\n"; }
else { die "\n\n  [!] Error: The specified temporary folder is not a directory\n\n" if (!-d $tmpdir); }

@tmp = ({ id       => "Sample #1 " . ($enzymatic ? "[RNase V1]" : "[Non treated]"),
          file     => $sample1,
          key      => "sample1",
          fh       => undef,
          cursor   => 0 },
        { id       => "Sample #2 " . ($enzymatic ? "[Nuclease S1]" : "[DMS/SHAPE treatment]"),
          file     => $sample2,
          key      => "sample2",
          fh       => undef,
          cursor   => 0},
        { id       => "Sample #3 [CMCT treatment]",
          file     => $sample3,
          key      => "sample3",
          fh       => undef,
          cursor   => 0 });

if (!$sam) {

    ##
    # Adapter clipping
    ##
    
    if (!$clipped) {
    
        print "\n[+] Clipping adapter's sequence from sequencing reads...\n";
        
        foreach my $sample (0 .. $nsamples - 1) {
        
            my ($file, undef) = fileparse($tmp[$sample]->{file});
        
            my $pid = fork || exec($fastx . " -a " . $fa . " -l " . $fl . " -M 10 -Q " . $fq . " -i " . $tmp[$sample]->{file} . " -o " . $tmpdir . $tmp . "_" . $file . " 2>>" . $tmpdir . $tmp . "_" . $file . "_clipping.log");
            push(@pids, $pid);
            $tmp[$sample]->{file} = $tmpdir . $tmp . "_" . $file;
                
            print "\n  [-] Processing " . $tmp[$sample]->{id} . " (PID: " . $pid . ")";
        
        }
        
        waitpid($_, 0) for (@pids);
        @pids = ();
        
        for (0 .. $nsamples - 1) { die "\n\n  [!] Error: Unable to perform adapter clipping on " . $tmp[$_]->{id} . "." .
                                       "\n             Please check input file's format/quality and try again.\n\n" if (!-e $tmp[$_]->{file}); }
    
    }
    else {
	
	print "\n[+] Input FastQ files are already clipped. Skipping adapter clipping...";
	
	my ($file1, undef) = fileparse($sample1);
	my ($file2, undef) = fileparse($sample2);
	
	$tmp[0]->{file} = $tmpdir . $tmp . "_" . $file1;
	$tmp[1]->{file} = $tmpdir . $tmp . "_" . $file2;
	
	system("ln -s " . File::Spec->rel2abs($sample1) . " " . $tmp[0]->{file});
	system("ln -s " . File::Spec->rel2abs($sample2) . " " . $tmp[1]->{file});
        
        
        if (defined $sample3) {
            
            my ($file3, undef) = fileparse($sample3);
            $tmp[2]->{file} = $tmpdir . $tmp . "_" . $file3;
        
            system("ln -s " . File::Spec->rel2abs($sample3) . " " . $tmp[2]->{file});
            
        }
	
    }
    
    ##
    # Reads mapping
    ##
    
    print "\n\n[+] Mapping reads to transcriptome...\n";
    
    foreach my $sample (0 .. $nsamples - 1) {
    
        my $file = $tmp[$sample]->{file};
        $tmp[$sample]->{file} = $file . ".sam";
    
        my $pid = fork || exec($bowtie . ($trim3 ? " -3 " . $trim3 . " " : " ") . ($trim5 ? " -5 " . $trim5 . " " : " ") . "-q " . (defined $bv ? "-v " . $bv : "-n " . $bn) . " --norc " .
                               ($ba ? "-a" : "-m 1") . " --best --strata -p " . $bp . " --chunkmbs " . $bc . " -S \"" . $bi . "\" \"" . $file .
                               "\" 2>>\"" . $tmpdir . $tmp . "_" . $tmp[$sample]->{key} . "_mapping.log\" | grep -v '4\t\\*\t0\t0' > \"" . $tmp[$sample]->{file} . "\"");
        push(@pids, $pid);
            
        print "\n  [-] Mapping " . $tmp[$sample]->{id} . " (PID: " . $pid . ")";
    
    }
    
    waitpid($_, 0) for (@pids);
    @pids = ();
    
    print "\n\n[+] Mapping statistics:\n";
    
    foreach my $sample (0 .. $nsamples - 1) {
        
        my ($mapped, $failed, $suppressed, $reported) = bowtie_log($tmpdir . $tmp . "_" . $tmp[$sample]->{key} . "_mapping.log");
        my $total = $mapped + $failed + $suppressed;
        
        # If multi-mapping reads count is disabled, we store the number of mapped reads in each library for normalization, else we store the number of reported mappings
        $n{$tmp[$sample]->{key}} = $multimap ? $reported : $mapped;
        
        if (!defined $total) { die "\n  [!] An error has occurred while mapping reads to transcriptome\n\n"; }
        elsif ($mapped == 0) { die "\n  [!] All reads for " . $tmp[$sample]->{id} . " have failed to map." .
                                   "\n      Please check the transcriptome assembly and try again.\n\n"; }
        
        $mapped = sprintf("%.2f", $mapped / $total * 100) . "%";
        $failed = sprintf("%.2f", $failed / $total * 100). "%";
        $suppressed = sprintf("%.2f", $suppressed / $total * 100) . "%";
        
        print "\n  [*] Sample " . $tmp[$sample]->{id} . " [Mapped: " . $mapped . "; Failed: " . $failed . ($ba ? "]" : "; Suppressed: " . $suppressed . "]");
        
    }

    print "\n";

}
else {
    
    print "\n[+] Input files are in SAM format. Skipping reads mapping...";
    
    $tmp[0]->{file} = $sample1;
    $tmp[1]->{file} = $sample2;
    $tmp[2]->{file} = $sample3 if (defined $sample3);
    
}

##
# SAM Header Parsing
##

print "\n[+] Getting transcripts IDs and lengths...";

open(my $fh, $samtools . " view -S -H " . $tmp[0]->{file} . " 2>/dev/null |") or die "\n\n  [!] Error: Unable to read SAM file's header (" . $! . ")\n\n";
while (<$fh>) {
    
    chomp();
    
    if ($_ =~ m/^\@SQ\tSN:(.+?)\tLN:(\d+)$/) { $transcripts{$1} = $2; }
    
}
close($fh);

die "\n\n  [!] Error: Missing SAM file's header. Unable to get transcript details.\n\n" if (!keys(%transcripts));

if ($sam &&
    $sorted) { print "\n[+] SAM files are sorted. Skipping sorting..."; }
else {

    ##
    # SAM File Sorting
    ##
    
    print "\n[+] Sorting SAM files...\n";
    
    foreach my $sample (0 .. $nsamples - 1) {
    
        my $file = $tmp[$sample]->{file};
        $tmp[$sample]->{file} = $file . "_sorted.sam";
        
        if ($sam) {
           
            my ($filename, $dir, $suffix) = fileparse($tmp[$sample]->{file}, qr/\.[^.]*/);
	    $tmp[$sample]->{file} = $tmpdir . $tmp . "_" . $filename . $suffix;
	
	} 
    
        my $pid = fork || exec("LC_ALL=C sort -k 3,3 -k 4,4n -T \"" . $tmpdir . "\" \"" . $file . "\" | grep -v '^\@' > \"" . $tmp[$sample]->{file} . "\"");
        push(@pids, $pid);
        
        print "\n  [-] Sorting " . $tmp[$sample]->{id} . " (PID: " . $pid . ")";
    
    }
    
    waitpid($_, 0) for (@pids);
    @pids = ();
    
    $sample1 = $tmp[0]->{file};
    $sample2 = $tmp[1]->{file};
    $sample3 = $tmp[2]->{file} if (defined $sample3);
    
    print "\n";
    
}

##
#  Normalization
##

if ($scoringmethod == 1) {

    if ($sam) {
    
	my ($n1, $n2, $n3);
	
	if ($multimap) {
	
	    print "\n[+] Calculating normalization factors for multi-mapping reads...";
	    
	    $n1 = async{ `grep -v '^\@' "$sample1" | wc -l` };
	    $n2 = async{ `grep -v '^\@' "$sample2" | wc -l` };
	    $n3 = async{ `grep -v '^\@' "$sample3" | wc -l` } if (defined $sample3);
	
	}
	else {
	    
	    print "\n[+] Calculating normalization factors...";
    
	    $n1 = async{ `cut -f 1 "$sample1" | sort -k 1,1 -T "$tmpdir" | uniq | grep -v '^\@' | wc -l` };
	    $n2 = async{ `cut -f 1 "$sample2" | sort -k 1,1 -T "$tmpdir" | uniq | grep -v '^\@' | wc -l` };
	    $n3 = async{ `cut -f 1 "$sample3" | sort -k 1,1 -T "$tmpdir" | uniq | grep -v '^\@' | wc -l` } if (defined $sample3);
	    
	}
	
	$n{sample1} = $n1->join();
	$n{sample2} = $n2->join();
	$n{sample3} = $n3->join() if (defined $sample3);
	
	foreach my $treat (keys %n) { $n{$treat} =~ s/[^\d]//g; }
    
    }
    
    $kn2 = (($n{sample1} + $n{sample2}) / 2) / $n{sample1};
    $k2 = (($n{sample1} + $n{sample2}) / 2) / $n{sample2};
    
    if (defined $sample3) {
    
	$kn3 = (($n{sample1} + $n{sample3}) / 2) / $n{sample1};
	$k3 = (($n{sample1} + $n{sample3}) / 2) / $n{sample3};
	
    }
    
}

print "\n[+] Calculating normalized reactivity scores [0 (0) of " . keys(%transcripts) . " transcripts passed]";

open($tmp[$_]->{fh}, "<" . $tmp[$_]->{file}) or die "\n\n  [!] Error: Unable to read from SampleÊ#" . ($_ + 1) . " temporary SAM file (" . $! . ")\n\n" for (0 .. $nsamples - 1);

my $io = Data::IO::Sequence->new(file => $multifasta);
my ($processed, $passed) = (0, 0);

foreach my $transcript (sort keys %transcripts) {
    
    # @sample1, @sample2, and @sample3 contains the number of RT-stop/Nuclease cuts at each position
    # @cov1, @cov2, and @cov3 contains the number of full length reads covering each position
    
    my ($length, $empty, $fasta,
        @sample1, @sample2, @sample3, @cov1,
        @cov2, @cov3);
    $empty = 0;
    $fasta = $io->read();
    $length = $transcripts{$transcript};
    $processed++;
    
    die "\n\n  [!] Error: SAM header's sorting doesn't match FASTA file sorting\n\n" if ($transcript ne $fasta->id());
    
    print "\r[+] Calculating normalized reactivity scores [" . $passed . " (" . $processed . ") of " . keys(%transcripts) . " transcripts passed]";
    
    while(readline($tmp[0]->{fh})) {
        
        next if ($_ =~ m/^@/);
        
        chomp();
        my @line = split(/\t/, $_);
        
        next if ($line[1] & 16);
        
        if ($line[2] gt $transcript) {
            
            seek($tmp[0]->{fh}, $tmp[0]->{cursor}, 0);
            
            last;
            
        }
        elsif ($line[2] lt $transcript) {
            
            $tmp[0]->{cursor} = tell($tmp[0]->{fh});
            next;
            
        }
        
        $line[3] -= $trim5;
        $sample1[($line[3] - 2)]++ if ($line[3] >= 2 + $trim5);
        
        for my $i ($line[3] - 2 .. $line[3] + length($line[9]) - 1) {
            
            next if ($i < 0);               # In case the actual 5'-end of transcript starts before the annotated one
            last if ($i > $length - 1);     # In case the actual 3'-end of transcript ends after the annotated one
            
            $cov1[$i]++;
            
        }
        
        $tmp[0]->{cursor} = tell($tmp[0]->{fh});
        
    }
    
    while(readline($tmp[1]->{fh})) {
        
        next if ($_ =~ m/^@/);
        
        chomp();
        my @line = split(/\t/, $_);
       
        next if ($line[1] & 16);
       
        if ($line[2] gt $transcript) {
            
            seek($tmp[1]->{fh}, $tmp[1]->{cursor}, 0);
            
            last;
            
        }
        elsif ($line[2] lt $transcript) {
            
            $tmp[1]->{cursor} = tell($tmp[1]->{fh});
            next;
            
        }
        
        if ($line[3] >= 2 + $trim5) {
            
            $line[3] -= $trim5;
            $sample2[($line[3] - 2)]++;
            $empty = 1;
            
            for my $i ($line[3] - 2 .. $line[3] + length($line[9]) - 1) {
            
                next if ($i < 0);               # In case the actual 5'-end of transcript starts before the annotated one
                last if ($i > $length - 1);     # In case the actual 3'-end of transcript ends after the annotated one
            
                $cov2[$i]++;
            
            }
            
        }
        
        $tmp[1]->{cursor} = tell($tmp[1]->{fh});
       
    }
    
    if (defined $sample3) {
    
        while(readline($tmp[2]->{fh})) {
            
            next if ($_ =~ m/^@/);
            
            chomp();
            my @line = split(/\t/, $_);
           
            next if ($line[1] & 16);
           
            if ($line[2] gt $transcript) {
                
                seek($tmp[2]->{fh}, $tmp[2]->{cursor}, 0);
                
                last;
                
            }
            elsif ($line[2] lt $transcript) {
                
                $tmp[2]->{cursor} = tell($tmp[2]->{fh});
                next;
                
            }
            
            if ($line[3] >= 2 + $trim5) {
                
                $line[3] -= $trim5;
                $sample3[($line[3] - 2)]++;
                $empty = 1;
                
                for my $i ($line[3] - 2 .. $line[3] + length($line[9]) - 1) {
                
                    next if ($i < 0);               # In case the actual 5'-end of transcript starts before the annotated one
                    last if ($i > $length - 1);     # In case the actual 3'-end of transcript ends after the annotated one
                
                    $cov3[$i]++;
                
                }
                
            }
            
            $tmp[2]->{cursor} = tell($tmp[2]->{fh});
           
        }
        
    }
    
    next if (!$empty);
    
    my ($rtstops, @transcript, @score, @norm,
        @total);
    
    for (0 .. $length - 1) {
        
        $sample1[$_] ||= 0;
        $sample2[$_] ||= 0;
        $sample3[$_] ||= 0;
        $cov1[$_] ||= 0;
        $cov2[$_] ||= 0;
        $cov3[$_] ||= 0;
        
        $rtstops += $sample2[$_];
        $rtstops += $enzymatic ? $sample1[$_] : (defined $sample3 ? $sample3[$_] : 0);
        
        if ($scoringmethod == 2) {
            
            $total[0] += log($sample1[$_] + 1);
            $total[1] += log($sample2[$_] + 1);
            $total[2] += log($sample3[$_] + 1);
            
        }
        
    }
    
    next if ($rtstops / $length < $rs);
    
    for (0 .. $length - 1) {
        
        my ($norm2, $norm3, $score2, $score3,
            $score, $base, $covered);
	$norm3 = 0;
	$score3 = 0;
        
        $base = uc(substr($fasta->sequence(), $_, 1));
        
        if ($scoringmethod == 1) { # Kertesz et al., 2010
                                   # Incarnato et al., 2014
        
            my ($norm12, $norm13);
        
            $norm12 = $kn2 * $sample1[$_];
            $norm2 = ($avoid && !$enzymatic && $base !~ m/^[AC]$/ ? 0 : $k2 * $sample2[$_]);
            $score2 = ($avoid && !$enzymatic && $base !~ m/^[AC]$/ ? 0 : logarithm((($norm2 + $pseudocount) / ($norm12 + $pseudocount)), 2));
	    
	    if (defined $sample3) {
		
		$norm13 = $kn3 * $sample1[$_];
		$norm3 = ($avoid && !$enzymatic && $base !~ m/^[GT]$/ ? 0 : $k3 * $sample3[$_]);
		$score3 = ($avoid && !$enzymatic && $base !~ m/^[GT]$/ ? 0 : logarithm((($norm3 + $pseudocount) / ($norm13 + $pseudocount)), 2));
	    
	    }
        
        }
        else { # Ding et al., 2014
            
            my $norm1 = (log($sample1[$_] + 1) + $pseudocount) / (($total[0] / $length) + $pseudocount);
            $norm2 = ($avoid && !$enzymatic && $base !~ m/^[AC]$/ ? 0 : (log($sample2[$_] + 1) + $pseudocount) / (($total[1] / $length) + $pseudocount));
            $score2 = max(0, ($norm2 - $norm1));
	    
	    if (defined $sample3) {
		
		$norm3 = ($avoid && !$enzymatic && $base !~ m/^[GT]$/ ? 0 : (log($sample3[$_] + 1) + $pseudocount) / (($total[2] / $length) + $pseudocount));
		$score3 = max(0, ($norm3 - $norm1));
		
	    }
            
        }
        
        $score = $enzymatic ? $score2 : max(0, max($score2, $score3));
        
        # We avoid any 0 reactivity corresponding to an uncovered position
        $covered = 1 if (((!$avoid && (($enzymatic && ($cov1[$_] || $cov2[$_])) || (!$enzymatic && ($cov2[$_] || $cov3[$_])))) ||
                          (!$enzymatic && ($avoid && (($base !~ m/^[AC]$/ && $cov2[$_]) || ($base !~ m/^[GT]$/ && $cov3[$_]))))) ||
                         $normall);
        
        push(@transcript, join("\t", $base,
                                     $sample1[$_],
                                     $sample2[$_],
                                     $sample3[$_],
                                     sprintf("%." . $decimals . "f", $norm2),
                                     sprintf("%." . $decimals . "f", $norm3),
                                     sprintf("%." . $decimals . "f", $score2),
                                     sprintf("%." . $decimals . "f", $score3),
                                     sprintf("%." . $decimals . "f", $score)));
        
        push(@score, $score);
        push(@norm, $score) if ($covered);
        
    }
    
    @score = $normmethod > 1 ? ($normmethod == 2 ? winsorising_90(\@score, \@norm) :
                                                   boxplot_norm(\@score, \@norm)) : normalization_28(\@score, \@norm);
    
    next if (!@score);
    
    open(my $wh, ">" . $output . $transcript . ".spd") or die "\n\n  [!] Error: Unable to write " . $transcript . " SPD output file (" . $! . ")\n\n";
    select((select($wh), $|=1)[0]);
    
    for (my $i = 0; $i < @transcript; $i++) {
        
        print $wh $transcript[$i] . "\t" . sprintf("%." . $decimals . "f", $score[$i]) . "\t" . $cov1[$i] . "\t" . $cov2[$i] . "\t" . $cov3[$i] . "\n";
        
    }
    
    close($wh);
    
    $passed++;
    print "\r[+] Calculating normalized reactivity scores [" . $passed . " (" . $processed . ") of " . keys(%transcripts) . " transcripts passed]";
    
}

close($tmp[$_]->{fh}) for (0 .. $nsamples - 1);

if ($passed) {
    
    print "\n\n  [*] Processed transcripts:               " . $processed .
          "\n      Transcripts with reactive positions: " . $passed . "\n";
    
}
else {

    print "\n\n  [!] Warning: No transcript shows reactive positions." .
          "\n               Try to modify analysis settings, or to increase sequencing depth.\n";

}

cleanup();

print "\n[+] All done.\n\n";

sub cleanup {
    
    if (!$keep) {
    
        print "\n[+] Removing temporary files...";
        system("rm " . $tmpdir . $tmp . "* 2>/dev/null");
             
    }
    
}

sub bowtie_log {
    
    my $log = shift;
    
    my ($mapped, $failed, $suppressed, $reported);
    
    open(my $fh, "<" . $log) or die "\n  [!] Error: Unable to open Bowtie log file (" . $! . ")\n\n";
    while(<$fh>) {
        
        chomp();
        
        if ($_ =~ m/reads with at least one reported alignment: (\d+) /) { $mapped = $1; }
        elsif ($_ =~ m/reads that failed to align: (\d+) /) { $failed = $1; }
        elsif ($_ =~ m/reads with alignments suppressed due to -m: (\d+) /) { $suppressed = $1; }
	elsif ($_ =~ m/Reported (\d+) alignments to 1 output stream/) { $reported = $1; }
        
    }
    close($fh);
    
    return($mapped, $failed, $suppressed, $reported);
    
}

sub winsorising_90 {  # 90% Winsorising
    
    my ($s, $n) = @_;
    
    my ($percentile, @norm);
    @norm = @{$s};
    $percentile = percentile($n, 0.9); # 90th percentile
    
    return() if ($percentile == 0);
    
    for (@norm) {
        
        $_ = $percentile if ($_ > $percentile);
        $_ /= $percentile;
        
    }
    
    return(@norm);
    
}

sub normalization_28 {  # 2-8% Normalization
    
    my ($s, $n) = @_;
    
    my ($p2, $p8, $avg, @norm);
    $p2 = round(@{$n} / 100 * 2);
    $p8 = round(@{$n} / 100 * 8);
    @norm = @{$s};
    
    @{$n} = sort {$b <=> $a} @{$n};

    for(my $i = $p2; $i < ($p8 + $p2 + 1); $i++) { $avg += $n->[$i]; }

    $avg /= $p8;
    
    return() if ($avg == 0);
    
    $_ = max(0, min($_/$avg, 1)) for(@norm);
    
    return(@norm);
    
}

sub boxplot_norm {
    
    my ($s, $n) = @_;
    
    my ($iqrange, $max, $p10, $avg,
        @n, @norm);
    $iqrange = percentile($n, 0.75) - percentile($n, 0.25); # Interquartile range
    $max = percentile($n, 0.75) + ($iqrange * 1.5); # Above this value, data points are considered outliers
    @norm = @{$s};
    @{$n} = sort {$b <=> $a} @{$n};
    
    for (@{$n}) { shift(@{$n}) if ($_ >= $max); }
    
    $p10 = round(@{$n} / 100 * 10);
    
    for(my $i = 0; $i < ($p10 + 1); $i++) { $avg += $n->[$i]; }
    
    $avg /= $p10;
    
    return() if ($avg == 0);
    
    $_ = max(0, $_ / $avg) for(@norm); # Values will range between 0 and ~1.5 according to
                                       # "SHAPE-Directed RNA Secondary Structure Prediction" (Low et al., 2010)
    
    return(@norm);
    
}

sub help {
    
    print "\n  [!] Error: Invalid option. Please check the help\n" if ($_[0]);
    
    die <<HELP;
 
 RSF Analyzer (v0.1.0)
 Epigenetics Units @ HuGeF [Human Genetics Foundation]
 Group leader: Prof. Salvatore Oliviero
    
 Author:  Danny Incarnato (danny.incarnato[at]hugef-torino.org)
 Summary: Performs whole-transcriptome analysis and normalization of high-throughput
          RNA structural probing data (CIRS-seq, Structure-seq, SHAPE-seq, and PARS)
 
 Usage:   rsf-analyzer [Options]
 
 Options                             Description
 -1  or --sample1                    Sample #1 (NT/RNase V1) FastQ file (or SAM file, requires -S)
 -2  or --sample2                    Sample #2 (DMS/Nuclease S1) FastQ file (or SAM file, requires -S)
 -3  or --sample3                    Sample #3 (CMCT) FastQ file (or SAM file, requires -S)
                                     Note: Sample #3 is only used for CIRS-seq CMCT treatment
 -e  or --enzymatic                  Data is assumed to derive from enzymatic probing
                                     (Sample #1: RNase V1; Sample #2: Nuclease S1)
 -a  or --avoid-non-canonical        Avoids non-canonical reactive residues from the analysis of chemical probing data
                                     (only A/C residues are considered for DMS treatment, and
                                      only G/U residues are considered for CMCT treatment)
 -p  or --pseudocount                Pseudocount added to reactivities to avoid division by 0 (>0, Default: 1)
 -rs or --rt-stops                   Discards any transcript in which less than this number of RT-stops (or nuclease-cuts)
                                     have occurred on average in the DMS+CMCT (CIRS-seq), DMS (SHAPE-seq and Structure-seq),
                                     or S1+V1 (PARS) treatments (Default: 1)
 -t  or --tmp-dir                    Temporary directory (Default: /tmp)
 -o  or --output-dir                 Output directory (Default: analyzer_out/)
 -ow or --overwrite                  Overwrites output directory (if the specified path already exists)
 -k  or --keep-tmp                   Keep temporary files (for debug)
 -b  or --bowtie                     Path to Bowtie v1 executable (Default: assumes Bowtie is in PATH)
 -f  or --fastx                      Path to FASTX Clipper executable (Default: assumes FASTX Clipper is in PATH)
 -s  or --samtools                   Path to SAMTools executable (Default: assumes SAMTools is in PATH)
 -t5 or --trim-5prime                Number of bases to trim from 5'-end of the read (0-5 bases, Default: 0)
 -t3 or --trim-3prime                Number of bases to trim from 3'-end of the read (0-15 bases, Default: 0)
 -d  or --decimals                   Number of decimals for reporting reactivities (1-10, Default: 3)
 -mm or --multi-mapping              Count each occurrence of multi-mapping reads when normalizing libraries
                                     by their sequencing depth (Default: count each read once)
                                     Note: This option only applies with scoring method 1
 -sm or --scoring-method             Specifies the score calculation method (1-2, Default: 1): [1] Kertesz et al., 2010,
                                                                                                   Incarnato et al., 2014
                                                                                               [2] Ding et al., 2014
 -nm or --norm-method                Specifies the normalization method (1-3, Default: 1): [1] 2-8% Normalization
                                                                                           [2] 90% Winsorising 
                                                                                           [3] Box-plot Normalization
 -na or --norm-all                   Use all transcript's positions for score normalization.
                                     Note: The default behaviour is to exclude non-covered bases from score normalization
 -S  or --sam                        Allows to pass 3 SAM files instead of FastQ files, thus skipping the mapping step
 -r  or --sorted                     Assumes that SAM files are already sorted lexicographically by transcript ID,
                                     and numerically by position
 
 FASTX Clipper options
 -fa or --fastx-adapter              Sequence of 3' adapter for clipping (Default: TGGAATTCTCGGGTGCCAAGG)
 -fq or --fastx-qual                 FastQ files quality scale (33 [Default], or 64)
 -fl or --fastx-len                  Minimum length to keep reads after clipping (>=35, Default: 35)
 -c  or --clipped                    Assumes that reads have been already clipped
 
 Bowtie options
 -bn or --bowtie-n                   Use Bowtie mapper in -n mode (0-3 mismatches, Default: 2)
 -bv or --bowtie-v                   Use Bowtie mapper in -v mode (0-3 mismatches, Default: disabled)
 -ba or --bowtie-all                 Report all equally scoring positions for multi-mapping reads
                                     (Default: disabled, reports only uniquely mapped reads)
 -bc or --bowtie-chunkmbs            Maximum MB of RAM for best-first search frames (Default: 128)
 -bp or --bowtie-threads             Number of processors to use for each instance of Bowtie (Default: 1).
                                     Note: RSF Analyzer executes 1 instance of Bowtie for each sample.
                                           At least n samples * bowtie-threads processors are required.
 -bi or --bowtie-index               Path to transcriptome reference index
 
 
 RSF Analyzer generates a set of SDF (Structure Probing Data) textual files, one for each transcript being analyzed.
 Each output file is composed of 10 TAB-delimited fields:
 
  1. Nucleotide residue
  2. Non treated control (CIRS-seq, SHAPE-seq, and Structure-seq) or RNase V1 (PARS) raw reads count
  3. DMS treatment (CIRS-seq, SHAPE-seq, and Structure-seq) or Nuclease S1 (PARS) raw reads count
  4. CMCT treatment raw reads count (CIRS-seq only, this field is always 0 for all the other protocols)
  5. DMS (CIRS-seq, SHAPE-seq, and Structure-seq) or RNase V1 (PARS) normalized reactivity
  6. CMCT normalized reactivity (CIRS-seq only, this field is always 0 for all the other protocols)
  7. DMS score (CIRS-seq, SHAPE-seq, and Structure-seq) or PARS score (PARS)
  8. CMCT score (CIRS-seq only, this field is always 0 for all the other protocols)
  9. Overall score
 10. Normalized reactivity (see -nm or --norm-method)
 11. Coverage in the Sample #1 library
 12. Coverage in the Sample #2 library
 13. Coverage in the Sample #3 library (CIRS-seq only, this field is always 0 for all the other protocols)
 
 where the coverage on each residue for a given library is calculated as the sum of the RT-stops (CIRS-seq,
 SHAPE-seq, and Structure-seq), or nuclease cuts (PARS), occurred on that residue, and the number of full-length
 reads covering the residue.
 
HELP
    
}
