#!/usr/bin/perl

##
# RSF Reference Builder (v0.1.0)
# Epigenetics Unit @ HuGeF [Human Genetics Foundation]
#
# Author:  Danny Incarnato (danny.incarnato[at]hugef-torino.org)
# Summary: Automatically queries UCSC genome database and builds the transcriptome Bowtie
#          reference index for the RSF Analyzer module
#
# This program is free software, and can be redistribute  and/or modified
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# Please see <http://www.gnu.org/licenses/> for more informations.
##

use strict;
use DBI;
use File::Which;
use FindBin qw($Bin);
use Getopt::Long qw(:config no_ignore_case);
use LWP::UserAgent;
use XML::Simple;

use lib $Bin . "/lib";

use Core::Mathematics;

$|++;

my ($dbh, $sth, $assembly, $annotation,
    $reference, $output, $bb, $ffb,
    $prefix, $timeout, $help, @columns,
    %columns, %chromosomes);

$timeout = 180;
$assembly = "mm9";
$annotation = "refFlat";
@columns = qw(name chrom strand txStart
              txEnd cdsStart cdsEnd exonCount
              exonStarts exonEnds);

do {
    
    local $SIG{__WARN__} = sub { };

    GetOptions( "h|help"              => \$help,
                "g|genome-assembly=s" => \$assembly,
                "a|annotation=s"      => \$annotation,
                "r|reference=s"       => \$reference,
                "o|output-dir=s"      => \$output,
                "t|timeout=i"         => \$timeout,
                "b|bowtie-build=s"    => \$bb,
                "f|fastaFromBed=s"    => \$ffb ) or help(1);

};

help() if ($help);

$bb = which("bowtie-build") if (!defined $bb);
$ffb = which("fastaFromBed") if (!defined $ffb);
$prefix = $assembly . "_" . $annotation;
$output = $prefix . "/" if (!defined $output);
$output =~ s/\/?$/\//;

##
# Input validation
##

die "\n  [!] Error: No genome assembly specified\n\n" unless(defined $assembly);
die "\n  [!] Error: No genes annotation specified\n\n" unless(defined $annotation);
die "\n  [!] Error: Timeout value must be an integer greater than 0\n\n" if (!ispositive($timeout) ||
                                                                             !isint($timeout) ||
                                                                             $timeout == 0);
die "\n  [!] Error: Provided reference multi-FASTA file doesn't exist\n\n" if (defined $reference &&
                                                                               !-e $reference);

if (!defined $bb) { die "\n  [!] Error: bowtie-build is not in PATH\n\n"; }
elsif (!-e $bb) { die "\n  [!] Error: bowtie-build doesn't exist\n\n"; }
elsif (!-x $bb) { die "\n  [!] Error: bowtie-build is not executable\n\n"; }

if (!defined $ffb) { die "\n  [!] Error: fastaFromBed is not in PATH\n\n"; }
elsif (!-e $ffb) { die "\n  [!] Error: fastaFromBed doesn't exist\n\n"; }
elsif (!-x $ffb) { die "\n  [!] Error: fastaFromBed is not executable\n\n"; }

print "\n[+] Making output directory...";

if (!-e $output) { mkdir($output, 0755) or die "\n\n  [!] Error: Unable to create output directory\n\n"; }
else { die "\n\n  [!] Error: Output directory already exists\n\n"; }

print "\n[+] Connecting to UCSC genome database (genome-mysql.cse.ucsc.edu:3306)...";

eval { $dbh = DBI -> connect( "DBI:mysql:database=" . $assembly . ";host=genome-mysql.cse.ucsc.edu;port=3306;mysql_connect_timeout=" . $timeout . ";",
                              "genomep",
                              "password",
                              { RaiseError => 1,
                                PrintError => 0,
                                AutoCommit => 1 } ); };

if ($@) {

    system("rm -R " . $output . " 2>/dev/null");
    
    die "\n\n  [!] Error: Connection to UCSC genome database failed." .
        "\n             Please check the genome assembly and try again.\n\n";
        
}

print "\n[+] Connected. Searching annotation...";

if (!table_exists($annotation)) {
    
    system("rm -R " . $output . " 2>/dev/null");
    
    die "\n\n  [!] Error: Table \"" . $annotation . "\" doesn't exist." .
        "\n             Please check annotation's name and try again\n\n";
    
}

print "\n[+] Annotation found. Validating columns...";

$sth = $dbh->prepare("SELECT * FROM `" . $annotation . "` LIMIT 0,1");
eval { $sth->execute() };

%columns = map { $_ => 1 } @{$sth->{NAME}};

for (@columns) {
    
    if (!exists $columns{$_}) {
        
        system("rm -R " . $output . " 2>/dev/null");
        
        die "\n\n  [!] Error: Table \"" . $annotation . "\" doesn't look like a genes annotation (missing \"" . $_ . "\" column)\n\n";
        
    }
    
}

print "\n[+] Downloading annotation data. Please wait...";

$sth = $dbh->prepare("SELECT * FROM `" . $annotation . "`");
eval { $sth->execute() };

if ($@) {

    system("rm -R " . $output . " 2>/dev/null");
        
    die "\n\n  [!] Error: Annotation data download failed\n\n";

}
else {
    
    open(my $wh, "| LC_ALL=C sort -k 1,1 -k 2,2n > \"" . $output . $prefix . ".bed\"") or die "\n\n  [!] Error: Unable to write annotation output BED file (" . $! . ")\n\n";
    select((select($wh), $|=1)[0]);

    while (my $ref = $sth->fetchrow_hashref()) {

        my (@starts, @ends, @length);
        @starts = split(/,/, $ref->{exonStarts});
        @ends = split(/,/, $ref->{exonEnds});
        
        for (0 .. $#starts) {
            
            push(@length, $ends[$_] - $starts[$_]);
            $starts[$_] -= $ref->{txStart};
            
        }
        
        print $wh join("\t", $ref->{chrom}, $ref->{txStart}, $ref->{txEnd}, ($ref->{geneName} ? $ref->{geneName} . "|" . $ref->{name} : $ref->{name}), 0, $ref->{strand}, $ref->{cdsStart}, $ref->{cdsEnd}, "0,0,0", $ref->{exonCount}) .
                  "\t" .  join(",", @length) . ",\t" . join(",", @starts) . ",\n";
        
        $chromosomes{$ref->{chrom}} = 1;

    }
    
    close($wh);    

    $sth->finish();
    $dbh->disconnect();

}

if (!defined $reference) {
    
    my $longer = length(shift(@{[sort {length($b) <=> length($a)} keys %chromosomes]}));    # Take the length of the longer chromosome name
    
    print "\n\n  [!] Warning: No reference multi-FASTA file has been provided." .
          "\n               RSF Reference Builder will now try to download reference" .
          "\n               genome sequence from UCSC DAS server." .
          "\n               This may take up to hours, depending on your connection's speed.\n" .
          "\n[+] Downloading sequence data for " . keys(%chromosomes) . " chromosomes. Please wait...\n";
          
    open(my $wh, ">" . $output . $assembly . ".fa") or die "\n\n  [!] Error: Unable to write reference output FASTA file (" . $! . ")\n\n";
    select((select($wh), $|=1)[0]);
    
    foreach my $chromosome (sort keys %chromosomes) {
        
        my ($ua, $size, $downloaded, $content,
            $reply, $status, $xml, $spacer);
        $ua = LWP::UserAgent->new(timeout => $timeout);
        $size = 0;
        $downloaded = 0;
        $spacer = " " x ($longer - length($chromosome) + 1);
        
        print "\n  [*] Chromosome " . $chromosome . $spacer . "[0.00%]";
        
        $reply = $ua->get("http://genome.ucsc.edu/cgi-bin/das/" . $assembly . "/dna?segment=" . $chromosome,
                          ":content_cb" => sub {
                            
                            my ($chunk, $response, $protocol) = @_;
                            my $percentage = 0;
                            
                            # We estimate the size of the data from the DNA tag
                            if (!$size && $chunk =~ m/<DNA length="(\d+)">/) { $size = $1; }
                              
                            $downloaded += length($chunk);
                            $percentage = sprintf("%.2f", $downloaded / $size * 100);
                            
                            print "\r  [*] Chromosome " . $chromosome . $spacer . "[" . ($percentage > 100 ? "100.00" : $percentage) . "%]";
                              
                            $content .= $chunk;
                            
                          });
        
        ($status) = $reply->header("x-das-status") =~ m/(\d+)/;
        
        if (!$reply->is_success() ||
            $status != 200) {
            
            system("rm -R " . $output . " 2>/dev/null");
            
            die "\n\n  [!] Error: Failed to retrieve sequence for chromosome " . $chromosome . " (" . $reply->message() . ")\n\n";
            
        }
        
        $xml = eval { XMLin($content) };
        
        if ($@) {
            
            system("rm -R " . $output . " 2>/dev/null");
            
            die "\n\n  [!] Error: Failed to parse UCSC DAS XML reply (" . $@ . ")\n\n";
            
        }
        
        $xml->{SEQUENCE}->{DNA}->{content} =~ s/^\n+//g;
        
        print $wh ">" . $chromosome . "\n" . $xml->{SEQUENCE}->{DNA}->{content};
        
    }
    
    close($wh);
    
    print "\n";
    
    $reference = $output . $assembly . ".fa";
    
}

print "\n[+] Extracting transcript sequences...";

system($ffb . " -fi " . $reference . " -fo " . $output . $prefix . "_tmp.fa -bed " . $output . $prefix . ".bed -name -s -split 2>" . $output . "fastaFromBed.log");

die "\n\n  [!] Error: Transcripts sequence extraction failed." .
    "\n             Please check that the log file and ensure that the installed bedTools version is >= 2.17.0.\n\n" unless(-s $output . $prefix . "_tmp.fa");
    
print "\n[+] Sorting transcripts by ID...";

system("awk 'BEGIN{RS=\">\"} NR>1 {gsub(\"\\n\", \"\\t\"); print \">\"\$0}' \"" . $output . $prefix . "_tmp.fa\" | LC_ALL=C sort -t ' ' -k2,2 | awk '{sub(\"\\t\", \"\\n\"); gsub(\"\\t\", \"\"); print \$0}' > \"" . $output . $prefix . ".fa\"");
system("rm " . $output . $prefix . "_tmp.fa");

print "\n[+] Building Bowtie transcriptome index from sequences. Please wait...";

system($bb . " " . $output . $prefix . ".fa " . $output . $prefix . " 2>&1 > " . $output . "bowtie-build.log");

for(qw(.1.ebwt .2.ebwt .3.ebwt .4.ebwt
       .rev.1.ebwt .rev.2.ebwt)) { die "\n\n  [!] Error: Bowtie transcriptome index generation failed." .
                                       "\n             Bowtie index file \"" . $prefix . $_ . "\" is missing. Please check the log file.\n\n" unless(-e $output . $prefix . $_); }

print "\n[+] Successfully built Bowtie index for " . $annotation . " annotation on assembly " . $assembly . "..." .
      "\n[+] All done.\n\n";

unlink($output . "fastaFromBed.log");
unlink($output . "bowtie-build.log");

sub table_exists { return(scalar(@{$dbh->selectcol_arrayref("SHOW TABLES LIKE '" . $_[0] . "'")})); }

sub help {
    
    print "\n  [!] Error: Invalid option. Please check the help\n" if ($_[0]);
    
    die <<HELP;
 
 RSF Reference Builder (v0.1.0)
 Epigenetics Units @ HuGeF [Human Genetics Foundation]
 Group leader: Prof. Salvatore Oliviero
    
 Author:  Danny Incarnato (danny.incarnato[at]hugef-torino.org)
 Summary: Automatically queries UCSC genome database and builds the transcriptome Bowtie
          reference index for the RSF Analyzer module
 
 Usage:   rsf-reference-builder [Options]
 
 Options                             Description
 -g  or --genome-assembly            Genome assembly for the species of interest (Default: mm9)
 -a  or --annotation                 Name of the UCSC table containing the genes annotation (Default: refFlat)
 -t  or --timeout                    Connection's timeout in seconds (Default: 180)
 -r  or --reference                  Path to a multi-FASTA file containing chromosome (or scaffold) sequences for the chosen genome assembly
                                     Note: if no file is specified, RSF Reference Builder will try to obtain sequences from
                                     UCSC DAS server. This process may take up to hours, depending on your connection's speed.
 -o  or --output-dir                 Bowtie index output directory (Default: <assembly>_<annotation>, e.g. "mm9_refFlat/")
 -b  or --bowtie-build               Path to bowtie-build executable (Default: assumes bowtie-build is in PATH)
 -f  or --fastaFromBed               Path to fastaFromBed executable (Default: assumes fastaFromBed is in PATH)
 
HELP
    
}